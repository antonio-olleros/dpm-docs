{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DPM Expression Language (DPM-XL) Documentation","text":"<p>Welcome to the comprehensive documentation for the Data Point Model Expression Language (DPM-XL), a formal language for expressing data validation and calculation requirements in regulatory reporting.</p>"},{"location":"#what-is-dpm-xl","title":"What is DPM-XL?","text":"<p>The DPM Expression Language is a formal, business-user-friendly language that enables the specification of:</p> <ul> <li>Data validation rules for regulatory reporting</li> <li>Calculation formulas for derived data points</li> <li>Data transformation operations across reporting tables</li> <li>Cross-module validations and consistency checks</li> </ul> <p>DPM-XL serves as the foundation for automated validation systems used by regulatory authorities such as EBA and EIOPA.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#business-oriented","title":"\ud83c\udfaf Business-Oriented","text":"<p>Designed for business users who understand regulatory requirements but may not be programmers.</p>"},{"location":"#formally-specified","title":"\u26a1 Formally Specified","text":"<p>Fully formalized syntax and semantics enable automated compilation and execution.</p>"},{"location":"#dual-representation","title":"\ud83d\udd04 Dual Representation","text":"<ul> <li>DPM-XL: Human-readable expression language</li> <li>DPM-ML: Machine-readable metamodel representation</li> </ul>"},{"location":"#rich-data-model","title":"\ud83d\udcca Rich Data Model","text":"<p>Supports complex data structures including scalars, sets, and multi-dimensional recordsets.</p>"},{"location":"#robust","title":"\ud83d\udee1\ufe0f Robust","text":"<p>Comprehensive null handling, type system, and error management.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple DPM-XL expression:</p> <pre><code>{F_01.01, r0010, c0010} = {F_01.01, r0020, c0010} + {F_01.01, r0030, c0010}\n</code></pre> <p>This expression validates that the value in table F_01.01, row 0010, column 0010 equals the sum of rows 0020 and 0030 in the same column.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<p>This documentation is organized to take you from basic concepts to advanced implementation:</p>"},{"location":"#introduction","title":"\ud83d\udcda Introduction","text":"<p>Learn about the motivation, design principles, and relationship between DPM-XL and DPM-ML.</p>"},{"location":"#information-model","title":"\ud83c\udfd7\ufe0f Information Model","text":"<p>Understand the core data structures: operations, artifacts (scalars, sets, recordsets), and data types.</p>"},{"location":"#language-specification","title":"\ud83d\udcdd Language Specification","text":"<p>Master the syntax rules, data selection mechanisms, and language features.</p>"},{"location":"#operators","title":"\u2699\ufe0f Operators","text":"<p>Comprehensive reference for all operators, organized by category: - Selection, Numeric, Comparison, Logical - Aggregate, Conditional, String, Time, Clause</p>"},{"location":"#dpm-ml","title":"\ud83d\udd27 DPM-ML","text":"<p>Learn about the metamodel representation and tree structures.</p>"},{"location":"#reference","title":"\ud83d\udcd6 Reference","text":"<p>Quick reference materials, grammar specifications, and operator summaries.</p>"},{"location":"#examples","title":"\ud83d\udca1 Examples","text":"<p>Practical examples from basic usage to complex edge cases.</p>"},{"location":"#who-should-use-this-documentation","title":"Who Should Use This Documentation?","text":""},{"location":"#regulatory-specialists","title":"Regulatory Specialists","text":"<p>Writing validation rules and calculations for regulatory frameworks.</p>"},{"location":"#software-developers","title":"Software Developers","text":"<p>Building engines and tools that execute DPM-XL expressions.</p>"},{"location":"#implementation-teams","title":"Implementation Teams","text":"<p>Integrating DPM-XL into reporting systems and validation pipelines.</p>"},{"location":"#standard-bodies","title":"Standard Bodies","text":"<p>Understanding the formal specification for governance and evolution.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<p>This documentation aims to be comprehensive and self-contained. Each section includes:</p> <ul> <li>Clear explanations of concepts</li> <li>Formal specifications where needed</li> <li>Practical examples</li> <li>Edge case handling</li> </ul> <p>For the most current information and updates, please refer to the official DPM standards documentation.</p> <p>Navigation Tip</p> <p>Use the navigation menu on the left to explore different sections. Each section builds upon previous concepts, so we recommend following the order for first-time readers.</p>"},{"location":"information-model/data-selection/","title":"3 DPM-XL data selection","text":"<p>The data for the expression language is selected by referencing the DPM Cells and Key Variables of DPM Report Tables.</p> <p>The references to the Cells and Key variables are done by means of the table codes, ordinate codes and the codes of the Properties associated to the Key Variables.</p> <p>The data selection is done by the interaction of the selection operator, represented by the curly brackets symbol, and the general scope of an expression, provided by the with operator. With this interaction, it is possible to individuate individual DPM Variables or sets of them. The actual data are referring to DPM Variables, thus making it possible to obtain the data required for the calculations.</p> <p>The selection of data, together with the DPM definitions, make it possible to determine the Structure of the Recordset on compile-time.</p>"},{"location":"information-model/dpm-ml/","title":"5 DPM-ML Metamodel","text":""},{"location":"information-model/dpm-ml/#51-operation-and-operationversion","title":"5.1 Operation and OperationVersion","text":"<p>Operations have a code and can be grouped.</p> <p>Groups of operations refer to the cases where users define a parent validation and the system derives automatically children validations. There can only be two levels of operations (i.e., a child validation cannot be the parent of another validation). The types of validations that generate children are Variant and Property constraint validations (see below).</p> <p>Operations and may be of any of 4 types:</p> <ul> <li>Validation: Operations that serve to validate the consistency of data. They can provide as output a scalar Boolean value or a recordset with scalar values.</li> <li>Calculation: Operations that serve to derive new data. They can provide as output any kind of data.</li> <li>Precondition: Operations that serve to determine whether one or more validations shall be applied. They can only provide as output a scalar Boolean value.</li> <li>Conditional_severity: Operations that serve to determine the severity of an invalid result for a validation. It can yield a value 'error' or 'warning'</li> </ul> <p>Operations are also classified based on their source for generation as:</p> <ul> <li>User_defined: Operations that have been defined by users.</li> <li>Hierarchy: Validations that have been automatically generated by the system based on the contents of subhierarchies.</li> <li>Sign: Validations that have been automatically generated by the system based on the contents of the Sign attribute for TableVersionCells.</li> <li>Existence: Validations that have been automatically generated by the system based on the IsNullable attribute for TableVersionCells.</li> <li>Variant: Validations that are defined at the level of TableGroups, including the individual validations generated from them.</li> <li>Property_contstraint: Validations that are defined at the level of a property, and from which individual instances of validations based on variables are generated.</li> </ul> <p>Operations can have many versions. A new version of an operation is required whenever any of the following attributes change:</p> <ul> <li>Expression: The DPM-XL expression of the version.</li> <li>Description: Natural language description of what the validation is aimed to check.</li> <li>PreconditionOperation: A link to an operation version that acts as precondition.</li> <li>SeverityOperation: A link to an operation that determines the conditional severity.</li> </ul>"},{"location":"information-model/dpm-ml/#52-operation-tree","title":"5.2 Operation tree","text":""},{"location":"information-model/dpm-ml/#521-operation-nodes","title":"5.2.1 Operation nodes","text":"<p>The tree representation of an OperationVersion is provided in the OperationNode table.</p> <p>Any Operation can be represented as a hierarchical tree, where the arguments of one Operator are represented.</p> <p>For instance, the expression:</p> <pre><code>A = B + C\n</code></pre> <p>Can be represented as:</p> <pre><code>    =\n   / \\\n  A   +\n     / \\\n    B   C\n</code></pre> <p>Where \"=\" and \"+\" are operators, and \"A\", \"B\" and \"C\" are operands.</p> <p>This kind of tree is represented in the OperationNode table.</p>"},{"location":"information-model/dpm-ml/#522-operands-representation","title":"5.2.2 Operands' representation","text":"<p>All Operands are represented as OperationNodes.</p> <p>Operands that are Scalars not representing a DPM Object (like an Item) are completely represented in the OperationNode table.</p> <p>Scalar Operands that are referring to a DPM Object need to be further specified with the tables OperandSource and OperandReference, which provide the reference to the DPM Object.</p> <p>Operands that are Variables and Sets of Variables need also to be further specified with the tables OperandSource and OperandReference. Concretely, for Sets of Variables, it is important to determine the index of each Variable in the context of the Operand, to be able to match the variables to which the operator applies.</p>"},{"location":"information-model/dpm-ml/#523-representation-example","title":"5.2.3 Representation example","text":"<p>For instance, suppose a table (Tab1) with three rows (100, 200 and 300), two columns (100 and 200) and two sheets.</p> <p>Sheet A</p> Column 100 Column 200 Row 100 1 4 Row 200 2 5 Row 300 3 6 <p>Sheet B</p> Column 100 Column 200 Row 100 7 10 Row 200 8 11 Row 300 9 12 <p>Note that each number in the cells represents the ID of the corresponding Variable.</p> <p>The following expression:</p> <pre><code>{tTab1, r100, c*, s*} = 2 * ({tTab1, r200, c*, s*} + {tTab1, r300, c*, s*})\n</code></pre> <p>Would be represented as the following tree:</p> <pre><code>             =\n           /   \\\n{tTab1, r100, c*, s*}   *\n                       / \\\n                      2   +\n                         / \\\n           {tTab1, r200, c*, s*} {tTab1, r300, c*, s*}\n</code></pre> <p>The representation in the DB would be as follows (only the relevant fields are shown, and for operators and argument simbols are used):</p> <p>OperationNode table</p> NodeId ParentNodeID Operator Argument OperandSourceId Scalar 1 = 2 1 left oprnd1 3 1 * right 4 3 left 2 5 3 + right 6 5 left oprnd2 7 5 right oprnd3 <p>OperandReference table</p> NodeID x y z VariableID 2 1 1 1 1 2 2 1 1 4 2 1 1 2 7 2 2 1 2 10 6 1 1 1 2 6 2 1 1 5 6 1 1 2 8 6 2 1 2 11 7 1 1 1 3 7 2 1 1 6 7 1 1 2 9 7 2 1 2 12 <p>Note that the operations shall be applied to the variables having the same index. For instance, Variable 1 = 2 * (Variable 2 + Variable 3), because all of them have the index y=1 and z=1.</p>"},{"location":"information-model/dpm-ml/#53-operation-scope","title":"5.3 Operation Scope","text":"<p>Each operation version can be applied in different scopes. An operation scope refers to the individual module versions or sets of module versions (for cross-module validations) to which the operation logically applies.</p> <p>For each operation scope, there may be different values for the attributes:</p> <ul> <li>IsActive: Determines whether the operation shall be run for a certain scope.</li> <li>Severity: Determines the severity of the error, if the validation is not passed.</li> <li>FromSubmissionDate: Sets a date from which the validation applies to subsequent submissions.</li> </ul>"},{"location":"information-model/dpm-ml/#54-variable-calculation","title":"5.4 Variable calculation","text":"<p>For calculations (i.e., operations that serve to calculate values for variables), it is necessary to link the operation to the actual variable that is generated. This is done with the VariableCalculation table, which links to the Variable and the Module. The link to the Module is necessary due to the fact that a Variable can be used in several Modules, being calculated in some cases and not calculated in other cases.</p>"},{"location":"information-model/information-model/","title":"2 Information Model","text":""},{"location":"information-model/information-model/#21-operations","title":"2.1 Operations","text":"<p>The DPM Operations serve to write Scripts, which are computer programs that constitute a run-time and are composed of Operations.</p> <p>Operations are expressions that use input operands and/or operators to produce a result.</p> <p>Expressions are finite combinations of symbols that are well-formed according to the syntactical rules of the language. Expressions compose some operands in a certain order by means of the operators of the language, to obtain the desired result. The symbols of the expression designate operators, operands, and the order of application of the operators.</p> <p>Operators specify a type of operation to be performed on some input operands (exceptionally, there may be operators that do not take operands as input, e.g., an operator to get the current time) to generate an output. The output produced by one operator may be used as input for another operator (i.e., operators can be nested).</p> <p>Operands are specific artifacts from the DPM Expression Language referenced in an expression as input.</p> <p>The result produced by an operation is also a specific artifact from the DPM Expression Language.</p>"},{"location":"information-model/information-model/#22-language-artifacts","title":"2.2 Language artifacts","text":"<p>DPM Expression Language calculations can operate on and generate as results three different type of Artifacts.</p>"},{"location":"information-model/information-model/#221-scalars","title":"2.2.1 Scalars","text":"<p>Scalars are individual values of a certain Data Type.</p>"},{"location":"information-model/information-model/#222-scalar-sets","title":"2.2.2 Scalar sets","text":"<p>Scalar Sets are sets of Scalar values defined on the same Data Type. Scalar Sets are typically used with the in operator.</p>"},{"location":"information-model/information-model/#223-recordsets","title":"2.2.3 Recordsets","text":"<p>Recordset are collections of Records that share a same Structure. Technically, Recordsets are two-dimensional labelled data structures (tabular), which can be assimilated to Relational Tables or Data Frames. The columns (fields) of the Recordset are provided by the Components of its Structure. The rows of the Recordset are its composing Records.</p> <p>The Structure of the Recordset is a collection of Components, which can have one of three roles: Key, Fact or Attribute. Each Component has a name, which must be unique within the Recordset. Key and Attribute Components are defined on a Data Type. Fact Components may be defined on more than one Data Type, when more than one variable is selected. In any case, the Data Type is known for each selected Variable.</p> <p>Each Record of the Recordset is individually identified by the combination of the values for its Key Components.</p> <p>A Recordset having no Key Components behaves like a Scalar.</p>"},{"location":"information-model/information-model/#2231-key-components","title":"2.2.3.1 Key components","text":"<p>Key Component may be Standard or DPM. Standard Key Components are different for DPM-ML and DPM-XL, although their behaviour is the same.</p> <p>Standard Key Components are common to all the Recordsets, independently on how the Variables are defined in the DPM. For each Recordset, there may be 0 or 1 occurrence of each subtype of Standard Key Component.</p>"},{"location":"information-model/information-model/#22311-standard-dpm-xl-key-components","title":"2.2.3.1.1 Standard DPM-XL Key Components","text":"<ul> <li>Row Key: Identifies the Row Ordinate from a Report Table where the selected Variable is located. Arises in Variable Set Selections, when more than one Row for one Report Table is selected. The name for the component is \"r\". It is defined on the String Data Type.</li> <li>Column Key: Identifies the Column Ordinate from a Report Table where the selected Variable is located. Arises in Variable Set Selections, when more than one Colum for one Report Table is selected. The name for the component is \"c\". It is defined on the String Data Type.</li> <li>Sheet Key: Identifies the Sheet Ordinate from a Report Table where the selected Variable is located. Arises in Variable Set Selections, when more than one Sheet for one Report Table is selected. The name for the component is \"s\". It is defined on the String Data Type.</li> </ul>"},{"location":"information-model/information-model/#22312-standard-dpm-ml-key-components","title":"2.2.3.1.2 Standard DPM-ML Key Components","text":"<p>Regarding the DPM-ML, the Standard Components are three indexes, which do not represent any DPM object. They just serve to make sure that the right variables are matched together when used with an operator. The names for these Components are \"x\", \"y\" and \"z\". Note that these indexes do not necessarily correspond to rows, columns, and sheets. During the conversion from DPM-XL, the values of the indexes for each variable shall be provided according to algorithms.</p>"},{"location":"information-model/information-model/#22313-dpm-key-components","title":"2.2.3.1.3 DPM Key Components","text":"<p>DPM Key Components are specific to how data is defined in the DPM. Arise when Open Variables are selected, and a Recordset will have one DPM Key Component per each Key Variable associated to the selected Variables.</p> <p>The name for the DPM Key Components is the Code of the Property associated to the DPM Key Variable.</p>"},{"location":"information-model/information-model/#2232-fact-component","title":"2.2.3.2 Fact Component","text":"<p>A Recordset has one mandatory, and only one, Fact Component. The name for the component is \"f\" Its data type depends on the Data Type of the selected Variables.</p> <p>If a DPM Key Variable is selected, the resulting Recordset will have the values for that Variable in the Fact Component, on top of having them in their corresponding Key Component. See example in section 2.2.4.4.</p>"},{"location":"information-model/information-model/#2233-attribute-components","title":"2.2.3.3 Attribute Components","text":"<p>Attribute Components provide additional information to the Fact value.</p> <p>DPM Attribute Components are specific to how data is defined in the DPM. Arise when a Variable with associated Attribute Variable is selected. A Recordset will have one DPM Attribute Component per each Property or Metric associated to any Attribute Variable associated to the selected Variables.</p> <p>The name for the DPM Attribute Components is the Code of the Property associated to the DPM Attribute Variable.</p>"},{"location":"information-model/information-model/#224-examples","title":"2.2.4 Examples","text":"<p>Recordsets arise from Open Variable selections or from selection of multiple Variables.</p>"},{"location":"information-model/information-model/#2241-closed-variable-selection","title":"2.2.4.1 Closed Variable Selection","text":"<p>For instance, taking as an example EBA's Table F 01.01:</p> <pre><code>{tF_01.01, r0010, c0010}\n</code></pre> <p>In the context of a single instance (i.e., disregarding the \"ref_date\" and the \"subject\"), selects a Recordset without Key Components, which works as a scalar with value 100.</p> <p>In the context of data with multiple dates and/or reference dates, and supposing that the data refer to the subject with code \"id123\" and to the date 31/12/2020, and that it has been reported with a 1 precision (attribute):</p> subject ref_date f p id123 2020-12-31 100 1"},{"location":"information-model/information-model/#2242-open-variable-selection","title":"2.2.4.2 Open Variable Selection","text":"<pre><code>{F 40.01 c0031}\n</code></pre> <p>Selects an Open Variable. In this illustrative example, yields a Recordset with three Records. The Recordset, in the context of a single instance, has two DPM Key Components, because the selected Variable (the one rendered in Column 0031 of Report Table F 40.01) is associated in the DPM to a Key with two Key Variables. These Key Variables are associated to Properties with codes \"LIN\" (rendered in Column 0011) and \"TYC\" (rendered in Column 0015).</p> <p>The following table represents the Recordset:</p> LIN TYC f 123456 LEI Name 1 123456 ISIN Name 2 1111 LEI Name 3"},{"location":"information-model/information-model/#2243-variable-set-selection","title":"2.2.4.3 Variable Set Selection","text":"<pre><code>{F 20.05 r0020-0030, c0010}\n</code></pre> <p>This case selects a set of Variables because the selection includes more than one Row. This implies that the Row Key Component applies to this Recordset. Besides, the selected Variables are associated to a Key with a single Key Variable, which is associated to a property with code \"RCP\".</p> RCP r f ES 0020 200 ES 0030 300 PT 0020 500 PT 0030 600 <p>In this case, the recordset for the DPM-ML would be slightly different because of the change in the Standard Key Component. Instead of the row, we would have any of the three indexes. For instance, using the x index:</p> RCP x f ES 1 200 ES 2 300 PT 1 500 PT 2 600 <p>Note that the important thing for DPM-ML to be consistent is that all the records with the same row share the same index.</p>"},{"location":"information-model/information-model/#2244-key-variable-selection","title":"2.2.4.4 Key Variable Selection","text":"<pre><code>{F 40.01 c0015}\n</code></pre> <p>Selects an Open Key Variable. The Recordset, in the context of a single instance, has two DPM Key Components, because the selected Variable (the one rendered in Column 0015 of Report Table F 40.01) is associated in the DPM to a Key with two Key Variables (in fact, it is part of the Key). These Key Variables are associated to Properties with codes \"LIN\" (rendered in Column 0011) and \"TYC\" (rendered in Column 0015).</p> <p>The following table represents the Recordset:</p> LIN TYC f 123456 LEI LEI 123456 ISIN ISIN 1111 LEI LEI <p>Note that the resulting Recordset has the values for the type of code two times, one as Key Component and another as Fact Component. This is necessary to allow doing calculations on the Fact while keeping all the Records in the Recordset uniquely identified.</p>"},{"location":"information-model/information-model/#23-data-types","title":"2.3 Data types","text":"<p>DPM Operations data types are defined with the principle: Create only a data type if they have different behaviour to other data types with at least one operator.</p> <p>The data types are:</p> <ul> <li>String: Sequence of alphanumeric characters of any length.</li> <li>Number: Is a rational number of any magnitude and precision, also used as approximation of a real number. Numbers can be treated as points or as intervals. Intervals are defined as a centre plus and minus a radius (c \u00b1 r). The centre is the input value provided. The radius is calculated based on the precision of the number as 10\u207b\u1d56/2.</li> <li>Integer: Positive and negative integer numbers and zero. It Is a subtype of the type number. As number subtypes, integers can be treated as intervals.</li> <li>Time interval denotes time intervals of any duration and expressed with a precision. According to ISO 8601 (ISO standard for the representation of dates and times), a time interval is the intervening time between two time points.</li> <li>Date is a subtype of the type time which denotes time points expressed at any precision, which are time intervals starting and ending in the same time point (i.e., intervals of zero duration). A value of type date includes all the parts needed to identify a time point at the desired precision, like the year, the month, the day, the hour, the minute and so on (for example, 2018-04-05 is the fifth of April 2018, at the precision of the day).</li> <li>Time period is a subtype of the type time, and denotes non-overlapping time intervals having a regular duration (for example the years, the quarters of years, the months, the weeks and so on). A value of the type time period is composite and must include all the parts needed to identify a regular time period at the desired precision; in particular, the time-period type includes the explicit indication of the kind of regular period considered (e.g., \"day\", \"week\", \"month\", \"quarter\" \u2026). For example, the value 2018M04, assuming that \"M\" stands for \"month\", denotes the month n.4 of the 2018 (April 2018). Moreover, 2018Q2, assuming that \"Q\" stands for 1896 \"quarter\", denotes the second quarter of 2018. In these examples, the letters M and Q are used to denote the kind of period through its duration.</li> <li>Boolean: denotes a logical binary state, meaning either \"true\" or \"false\".</li> <li>Category items: A reference to the code of a Category Item.</li> <li>Subcategories: A reference to the code of a Subcategory.</li> </ul>"},{"location":"information-model/information-model/#231-correspondences-with-dpm-data-types","title":"2.3.1 Correspondences with DPM data types","text":"<p>The DPM provides a wider list of data types. This is because greater granularity in the data typology may be useful for reporting or representation purposes (e.g., a monetary amount requires a currency attribute, while a pure number does not).</p> <p>For each DPM data type there is one, and only one DPM Operations data type.</p>"},{"location":"information-model/information-model/#232-casting","title":"2.3.2 Casting","text":"<p>The casting between data types is possible. Casting can be done explicitly, if the cast operator is used, or implicitly when it is allowed. The following table contains all the casting options.</p> String Number Integer Time interval Date Time period Duration Boolean Item Subcategory String Explicit Explicit Explicit Explicit Explicit Explicit Explicit Explicit Explicit Number Implicit Explicit Not possible Not possible Not possible Not possible Not possible Not possible Not possible Integer Implicit Implicit Not possible Not possible Not possible Not possible Not possible Not possible Not possible Time interval Implicit Not possible Not possible Explicit Explicit Not possible Not possible Not possible Not possible Date Implicit Not possible Not possible Implicit Explicit Not possible Not possible Not possible Not possible Time period Implicit Not possible Not possible Implicit Not possible Not possible Not possible Not possible Not possible Duration Implicit Not possible Not possible Not possible Not possible Not possible Not possible Not possible Not possible Boolean Implicit Not possible Not possible Not possible Not possible Not possible Not possible Not possible Not possible Item Implicit Not possible Not possible Not possible Not possible Not possible Not possible Not possible Not possible Subcategory Implicit Not possible Not possible Not possible Not possible Not possible Not possible Not possible Not possible"},{"location":"information-model/information-model/#233-conventions-to-write-scalars","title":"2.3.3 Conventions to write scalars","text":"<p>To the effects of DPM-XL, when writing scalars, the following conventions should be followed:</p> <ul> <li>String: Between double quotes (\"this is a string\") or single quotes ('this is also a string')</li> <li>Number: Sequence of numeric digits. Dot (\".\") shall be used to separate the decimal and the integer part.</li> <li>Integer: Sequence of numeric digits.</li> <li>Time Follows ISO 8601 (ISO standard for the representation of dates and times). Dates shall be written between hashes (#). A valid time representation is #2021-11-25/2021-12-25#</li> <li>Date #2021-11-25#.</li> <li>Time period #2021Q4#.</li> <li>Duration Following ISO8601: P[n]Y[n]M[n]DT[n]H[n]M[n]S. E.g.,: #P3Y6M4DT12H30M5S#</li> <li>Boolean: true or false.</li> <li>DPM objects: A string between brackets with two arguments, first the type and second the code. E.g., [item, eba_RT:x11], [subcategory, eba_CU:iso_currencies]</li> </ul>"},{"location":"information-model/introduction/","title":"Introduction","text":"<p>This is a technical document specifying the Information Model, the Data Types and other technical characteristics of the DPM Operations.</p> <p>This documentation is mainly addressed to technical audiences with interest in developing engines or in having a better technical understanding of the DPM Operations. The document is not addressed to normal business users that write calculations, although it can be useful for those users with basic knowledge of information models and programming languages.</p> <p>In any case, this document is complemented by the document describing the operators used for the operations, which should be the main reference for users writing calculations.</p>"},{"location":"information-model/introduction/#why","title":"Why","text":"<p>EBA and EIOPA have been using for some years a semi-formal expression language for business users to write and share their data validation requirements.</p> <p>The fact that is semi-formal allows automating some aspects for translating the expression into another language (e.g., XBRL Formula Link base). But because it is not completely formal, it is, by definition, not possible to create a compiler that fully automates the translation to another language or an interpreter for it.</p> <p>This document, and its complementary document on the operators, aims to provide this required formalization so that DPM Operations become fully formalised, therefore enabling the automation regarding the calculations written by EBA and EIOPA.</p>"},{"location":"information-model/introduction/#dpm-xl-and-dpm-ml","title":"DPM-XL and DPM-ML","text":"<p>The DPM Operations have two representations: As expressions, with the DPM eXpression Language (DPM-XL) and as a structured representation in the database following a metamodel (DPM Metamodel Language or DPM-ML).</p> <p>The reason for having DPM-XL is that it is the language business users write and can understand. Because it is the input of all the process, it is important to keep this language formal, so that it can be translated and executed. But, at the same time, it must serve for communication, so it has to be business users friendly, implying, among others, that the operands of the language are referred to by using rendering artifacts (tables, row, columns and sheets).</p> <p>A key requirement for the DPM-XL has been that the language that is currently used should change as little as possible. So, in practice, the formalisation of the language has been a reverse-engineering process, where the starting point where the validations published by the EBA and EIOPA.</p> <p>The main reasons for having DPM-ML are that it is providing a structured version of the calculations, with no need to parse expressions, and that it is referring to variables, which are stable over time, because they represent business concepts, instead of rendering objects, which change often over time and do not hold any business meaning, but just a representation.</p> <p>The DPM-ML is automatically derived from the DPM-XL and, eventually, can be also derived from languages other than the DPM-XL. DPM-ML relations to languages other than DPM-XL is out of the scope for this documentation. Instead, the documentation provides details on how operations are represented both in DPM-XL and DPM-ML. The DPM-XL and DPM-ML share the same operators and the same information model.</p>"},{"location":"information-model/introduction/#how","title":"How","text":"<p>The formalisation of the language has tree pillars:</p> <ol> <li>Information model: Specifies the artefacts that the language is using.</li> <li>Grammar: Technical definition of the syntax of the language. Allows developers to build parsers for the language. It is provided in a separate file following the EBNF (Extended Backus-Naur form) notation (Only applicable to DPM-XL).</li> <li>Semantic specification: Semantics for all operators of the language, specifying formally their constraints and behaviour.</li> </ol> <p>This document deals with the information model, while the grammar and semantic specification are provided as separate documents.</p> <p>The Validation and Transformation Language specification has been used as an inspiration for this specification.</p>"},{"location":"information-model/null-treatment/","title":"4 Null in DPM Expression Language","text":""},{"location":"information-model/null-treatment/#41-null-and-data-types","title":"4.1 Null and data types","text":"<p>All the Data Types are assumed to contain the conventional value null, which means \"no value\", or \"absence of known value\" or \"missing value\". Note that the null value, therefore, is the only value of multiple different types.</p> <p>For the String Data Type, null is considered equivalent to the empty string.</p>"},{"location":"information-model/null-treatment/#42-implicit-an-explicit-null-values","title":"4.2 Implicit an explicit null values","text":"<p>For Recordsets, nulls may arise in a selection for two reasons:</p> <ul> <li>Explicit null: In the input data for the engine, there is a record without a value.</li> <li>Implicit null: In the input data for the engine, there is no record for one of the Variables in the selection. In this case, the engine will generate a record for that variable with a null value, or another specified default (see Selection Operator in part 2).</li> </ul> <p>In any case, there are no differences in how implicit or explicit nulls are treated.</p>"},{"location":"information-model/null-treatment/#43-null-treatment","title":"4.3 Null treatment","text":"<p>In general, most of the operations return null when any of their arguments is null.</p> <ul> <li>Comparison operators (e.g., -, &gt;): if a null is involved in the operation, then the result is null.</li> <li>Arithmetic operators (e.g., + , -, *): if a null is involved in the operation, then the result is null.</li> <li>String operators: null is considered an empty string.</li> <li>Logical operators (and, or, xor, not): Three-value logic is adopted with the consideration that null means unknown. The concrete results for each operator are specified in part 2, in the description of the operators.</li> <li>Conditional operators: null is considered equivalent to false.</li> <li>Filtering: null is considered equivalent to false (i.e., the Records with a null value are not selected in the filter).</li> <li>Aggregations (e.g., sum, avg, max): nulls are excluded from the calculations.</li> <li>Intervals: If the centre is null, the radius is also null.</li> </ul>"},{"location":"information-model/null-treatment/#44-overriding-the-standard-null-treatment","title":"4.4 Overriding the standard null treatment","text":"<p>The standard null treatment can be overriding by substituting the null values for other values. This can be done in two ways:</p> <ul> <li>With the Selection Operator: It is possible to set a default value in the selection for the null values.</li> <li>With the nvl Operator: serves to substitute nulls for any value.</li> </ul>"}]}