{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DPM Expression Language (DPM-XL) Documentation","text":"<p>Welcome to the comprehensive documentation for the Data Point Model Expression Language (DPM-XL), a formal language for expressing data validation and calculation requirements in regulatory reporting.</p>"},{"location":"#what-is-dpm-xl","title":"What is DPM-XL?","text":"<p>The DPM Expression Language is a formal, business-user-friendly language that enables the specification of:</p> <ul> <li>Data validation rules for regulatory reporting</li> <li>Calculation formulas for derived data points</li> <li>Data transformation operations across reporting tables</li> <li>Cross-module validations and consistency checks</li> </ul> <p>DPM-XL serves as the foundation for automated validation systems used by regulatory authorities such as EBA and EIOPA.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#business-oriented","title":"\ud83c\udfaf Business-Oriented","text":"<p>Designed for business users who understand regulatory requirements but may not be programmers.</p>"},{"location":"#formally-specified","title":"\u26a1 Formally Specified","text":"<p>Fully formalized syntax and semantics enable automated compilation and execution.</p>"},{"location":"#dual-representation","title":"\ud83d\udd04 Dual Representation","text":"<ul> <li>DPM-XL: Human-readable expression language</li> <li>DPM-ML: Machine-readable metamodel representation</li> </ul>"},{"location":"#rich-data-model","title":"\ud83d\udcca Rich Data Model","text":"<p>Supports complex data structures including scalars, sets, and multi-dimensional recordsets.</p>"},{"location":"#robust","title":"\ud83d\udee1\ufe0f Robust","text":"<p>Comprehensive null handling, type system, and error management.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple DPM-XL expression:</p> <pre><code>{F_01.01, r0010, c0010} = {F_01.01, r0020, c0010} + {F_01.01, r0030, c0010}\n</code></pre> <p>This expression validates that the value in table F_01.01, row 0010, column 0010 equals the sum of rows 0020 and 0030 in the same column.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<p>This documentation is organized to take you from basic concepts to advanced implementation:</p>"},{"location":"#introduction","title":"\ud83d\udcda Introduction","text":"<p>Learn about the motivation, design principles, and relationship between DPM-XL and DPM-ML.</p>"},{"location":"#information-model","title":"\ud83c\udfd7\ufe0f Information Model","text":"<p>Understand the core data structures: operations, artifacts (scalars, sets, recordsets), and data types.</p>"},{"location":"#language-specification","title":"\ud83d\udcdd Language Specification","text":"<p>Master the syntax rules, data selection mechanisms, and language features.</p>"},{"location":"#operators","title":"\u2699\ufe0f Operators","text":"<p>Comprehensive reference for all operators, organized by category: - Selection, Numeric, Comparison, Logical - Aggregate, Conditional, String, Time, Clause</p>"},{"location":"#dpm-ml","title":"\ud83d\udd27 DPM-ML","text":"<p>Learn about the metamodel representation and tree structures.</p>"},{"location":"#reference","title":"\ud83d\udcd6 Reference","text":"<p>Quick reference materials, grammar specifications, and operator summaries.</p>"},{"location":"#examples","title":"\ud83d\udca1 Examples","text":"<p>Practical examples from basic usage to complex edge cases.</p>"},{"location":"#who-should-use-this-documentation","title":"Who Should Use This Documentation?","text":""},{"location":"#regulatory-specialists","title":"Regulatory Specialists","text":"<p>Writing validation rules and calculations for regulatory frameworks.</p>"},{"location":"#software-developers","title":"Software Developers","text":"<p>Building engines and tools that execute DPM-XL expressions.</p>"},{"location":"#implementation-teams","title":"Implementation Teams","text":"<p>Integrating DPM-XL into reporting systems and validation pipelines.</p>"},{"location":"#standard-bodies","title":"Standard Bodies","text":"<p>Understanding the formal specification for governance and evolution.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<p>This documentation aims to be comprehensive and self-contained. Each section includes:</p> <ul> <li>Clear explanations of concepts</li> <li>Formal specifications where needed</li> <li>Practical examples</li> <li>Edge case handling</li> </ul> <p>For the most current information and updates, please refer to the official DPM standards documentation.</p> <p>Navigation Tip</p> <p>Use the navigation menu on the left to explore different sections. Each section builds upon previous concepts, so we recommend following the order for first-time readers.</p>"},{"location":"information-model/","title":"Information Model","text":"<p>The Information Model forms the conceptual foundation of DPM-XL, defining the data structures, types, and relationships that the language operates upon. This model is independent of syntax and provides the vocabulary for all semantic specifications.</p>"},{"location":"information-model/#core-concepts","title":"Core Concepts","text":"<p>The Information Model deals with four fundamental concepts:</p> graph TB     OP[Operations] --&gt; ART[Language Artifacts]     ART --&gt; SC[Scalars2]     ART --&gt; SS[Scalar Sets]       ART --&gt; RS[Recordsets]      OP --&gt; DT[Data Types]     DT --&gt; NUM[Numeric Types]     DT --&gt; STR[String Types]     DT --&gt; TIME[Time Types]     DT --&gt; BOOL[Boolean]     DT --&gt; CAT[Category Types]      style OP fill:#e3f2fd     style ART fill:#f3e5f5     style DT fill:#e8f5e8"},{"location":"information-model/#what-youll-learn","title":"What You'll Learn","text":"<p>This section provides comprehensive coverage of the Information Model through several focused areas:</p>"},{"location":"information-model/#operations","title":"Operations","text":"<p>The structural foundation of DPM-XL expressions: - How operations are composed of operators, operands, and results - The relationship between scripts and individual operations - How operators transform operands into results</p>"},{"location":"information-model/#language-artifacts","title":"Language Artifacts","text":"<p>The three core data structures that DPM-XL manipulates: - Scalars: Individual values of specific data types - Scalar Sets: Collections of scalar values - Recordsets: Complex tabular data structures</p>"},{"location":"information-model/#data-types","title":"Data Types","text":"<p>The complete type system including: - Numeric types (Number, Integer, with interval support) - Text types (String) - Temporal types (Date, Time Period, Time Interval, Duration) - Logical types (Boolean) - Reference types (Category Items, Subcategories) - Type casting and conversion rules</p>"},{"location":"information-model/#examples","title":"Examples","text":"<p>Practical illustrations showing how the Information Model concepts work together in real scenarios.</p>"},{"location":"information-model/#key-principles","title":"Key Principles","text":"<p>The Information Model is designed around several key principles:</p>"},{"location":"information-model/#type-safety","title":"Type Safety","text":"<p>Every operation has well-defined input and output types, with explicit casting rules where conversion is possible.</p>"},{"location":"information-model/#structural-clarity","title":"Structural Clarity","text":"<p>Complex data structures (recordsets) have well-defined components with specific roles (keys, facts, attributes).</p>"},{"location":"information-model/#business-alignment","title":"Business Alignment","text":"<p>Data structures map directly to concepts familiar to business users (tables, rows, columns, variables).</p>"},{"location":"information-model/#computational-completeness","title":"Computational Completeness","text":"<p>The model supports all operations needed for regulatory validation and calculation scenarios.</p>"},{"location":"information-model/#relationship-to-implementation","title":"Relationship to Implementation","text":"<p>While the Information Model is conceptual, it directly drives implementation requirements:</p>"},{"location":"information-model/#memory-models","title":"Memory Models","text":"<p>Defines how data should be structured in memory during execution.</p>"},{"location":"information-model/#type-systems","title":"Type Systems","text":"<p>Provides the specification for runtime type checking and casting.</p>"},{"location":"information-model/#data-validation","title":"Data Validation","text":"<p>Establishes rules for validating input data and intermediate results.</p>"},{"location":"information-model/#error-handling","title":"Error Handling","text":"<p>Specifies when operations should fail and what constitutes valid inputs.</p>"},{"location":"information-model/#model-independence","title":"Model Independence","text":"<p>Importantly, the Information Model is:</p> <ul> <li>Syntax Independent: The same model applies to both DPM-XL expressions and DPM-ML structures</li> <li>Implementation Independent: Can be realized in any programming language or database system</li> <li>Platform Independent: Works across different execution environments</li> </ul> <p>This independence ensures that the conceptual foundation remains stable even as syntax or implementation details evolve.</p> <p>Reading Guide</p> <p>The Information Model sections build upon each other:</p> <ol> <li>Start with Operations to understand the basic structure</li> <li>Move to Language Artifacts to understand data structures</li> <li>Study Data Types for the complete type system</li> <li>Review Examples to see concepts in practice</li> </ol>"},{"location":"information-model/data-types/","title":"Data Types","text":"<p>DPM-XL employs a carefully designed type system that balances expressiveness with operational efficiency. The guiding principle is: Create only a data type if it has different behavior from other data types with at least one operator.</p>"},{"location":"information-model/data-types/#type-hierarchy","title":"Type Hierarchy","text":"graph TD     DT[DPM-XL Data Types] --&gt; NUM[Numeric Types]     DT --&gt; STR[String]     DT --&gt; TIME[Temporal Types]     DT --&gt; BOOL[Boolean]     DT --&gt; CAT[Category Types]      NUM --&gt; NUMBER[Number]     NUM --&gt; INTEGER[Integer]      TIME --&gt; TINT[Time Interval]     TIME --&gt; DATE[Date]     TIME --&gt; TPER[Time Period]     TIME --&gt; DUR[Duration]      CAT --&gt; ITEM[Category Items]     CAT --&gt; SUBCAT[Subcategories]      style DT fill:#e3f2fd     style NUM fill:#f3e5f5     style TIME fill:#e8f5e8     style CAT fill:#fff3e0"},{"location":"information-model/data-types/#core-data-types","title":"Core Data Types","text":""},{"location":"information-model/data-types/#string","title":"String","text":"<p>Sequence of alphanumeric characters of any length.</p> <p>Characteristics: - Variable length (no predefined limit) - Unicode support for international characters - Empty string is valid and equivalent to null</p> <p>Examples: <pre><code>\"Hello World\"\n\"Asset Class A\"\n\"\"                    # Empty string\n'Alternative syntax'  # Single quotes also valid\n</code></pre></p>"},{"location":"information-model/data-types/#number","title":"Number","text":"<p>Rational number of any magnitude and precision, used as approximation of real numbers.</p> <p>Characteristics: - Arbitrary precision and magnitude - Can be treated as points or intervals - Intervals defined as center \u00b1 radius (c \u00b1 r) - Radius calculated as 10^(-p)/2 where p is precision</p> <p>Examples: <pre><code>3.14159\n-42.7\n1000000.001\n0.0001\n</code></pre></p>"},{"location":"information-model/data-types/#integer","title":"Integer","text":"<p>Positive and negative integer numbers and zero.</p> <p>Characteristics: - Subtype of Number - Can be treated as intervals like Numbers - Whole numbers only (no decimal component)</p> <p>Examples: <pre><code>42\n-17\n0\n1000000\n</code></pre></p>"},{"location":"information-model/data-types/#boolean","title":"Boolean","text":"<p>Logical binary state meaning either \"true\" or \"false\".</p> <p>Characteristics: - Only two valid values: <code>true</code> and <code>false</code> - Supports three-valued logic with null - Used in conditional and logical operations</p> <p>Examples: <pre><code>true\nfalse\n</code></pre></p>"},{"location":"information-model/data-types/#temporal-types","title":"Temporal Types","text":""},{"location":"information-model/data-types/#time-interval","title":"Time Interval","text":"<p>Denotes time intervals of any duration expressed with precision.</p> <p>Characteristics: - Represents intervening time between two time points - Follows ISO 8601 standard - Can have various precisions (year, month, day, etc.)</p> <p>Examples: <pre><code>#2023-01-01/2023-12-31#    # Full year interval\n#2023Q1/2023Q4#            # Multi-quarter interval\n</code></pre></p>"},{"location":"information-model/data-types/#date-subtype-of-time-interval","title":"Date (subtype of Time Interval)","text":"<p>Time points expressed at any precision - intervals of zero duration.</p> <p>Characteristics: - Includes all parts needed for desired precision - Can represent year, month, day, hour, minute, second - Always represents a specific point in time</p> <p>Examples: <pre><code>#2023-12-31#              # Specific date\n#2023-12-31T14:30:00#     # Date with time\n#2023#                    # Year precision\n</code></pre></p>"},{"location":"information-model/data-types/#time-period-subtype-of-time-interval","title":"Time Period (subtype of Time Interval)","text":"<p>Non-overlapping time intervals with regular duration.</p> <p>Characteristics: - Regular periods: years, quarters, months, weeks, days - Composite values with duration type indicator - Explicit indication of period type</p> <p>Examples: <pre><code>#2023M04#                 # April 2023 (month)\n#2023Q2#                  # Second quarter 2023\n#2023W15#                 # Week 15 of 2023\n</code></pre></p>"},{"location":"information-model/data-types/#duration","title":"Duration","text":"<p>Represents a length of time (not bound to specific dates).</p> <p>Characteristics: - Follows ISO 8601 duration format - P[n]Y[n]M[n]DT[n]H[n]M[n]S pattern - Can represent years, months, days, hours, minutes, seconds</p> <p>Examples: <pre><code>#P1Y#                     # 1 year\n#P3M#                     # 3 months  \n#P1Y6M#                   # 1 year and 6 months\n#PT2H30M#                 # 2 hours 30 minutes\n</code></pre></p>"},{"location":"information-model/data-types/#category-types","title":"Category Types","text":""},{"location":"information-model/data-types/#category-items","title":"Category Items","text":"<p>Reference to the code of a Category Item in the DPM model.</p> <p>Characteristics: - Points to specific items in DPM taxonomies - Provides type-safe references to enumerated values - Enables validation against official code lists</p> <p>Examples: <pre><code>[item, eba_RT:x11]\n[item, \"asset_class_equity\"]\n</code></pre></p>"},{"location":"information-model/data-types/#subcategories","title":"Subcategories","text":"<p>Reference to the code of a Subcategory in the DPM model.</p> <p>Characteristics: - References collections of related category items - Enables set-based operations on predefined groups - Provides centralized maintenance of code lists</p> <p>Examples: <pre><code>[subcategory, eba_CU:iso_currencies]\n[subcategory, \"eu_member_states\"]\n</code></pre></p>"},{"location":"information-model/data-types/#type-correspondence-with-dpm-types","title":"Type Correspondence with DPM Types","text":"<p>DPM-XL provides a simplified type system that maps to the more granular DPM data types:</p> DPM Code DPM Name DPM-XL Type <code>i</code> integer Integer <code>r</code> decimal Number <code>s</code> string (non empty) String <code>b</code> boolean Boolean <code>t</code> true Boolean <code>dt</code> date time Date <code>d</code> date Date <code>e</code> enumeration Category Items <code>m</code> monetary Number <code>p</code> percentage Number <code>u</code> URI String <code>o</code> ordinals Integer <code>es</code> string (including empty) String <p>This mapping enables DPM-XL to work with existing DPM models while maintaining a simpler type system for operations.</p>"},{"location":"information-model/data-types/#type-casting","title":"Type Casting","text":"<p>Type conversion between data types follows explicit rules:</p>"},{"location":"information-model/data-types/#casting-matrix","title":"Casting Matrix","text":"From / To String Number Integer Time Interval Date Time Period Duration Boolean Item Subcategory String - Explicit Explicit Explicit Explicit Explicit Explicit Explicit Explicit Explicit Number Implicit - Explicit \u274c \u274c \u274c \u274c \u274c \u274c \u274c Integer Implicit Implicit - \u274c \u274c \u274c \u274c \u274c \u274c \u274c Time Interval Implicit \u274c \u274c - Explicit Explicit \u274c \u274c \u274c \u274c Date Implicit \u274c \u274c Implicit - Explicit \u274c \u274c \u274c \u274c Time Period Implicit \u274c \u274c Implicit \u274c - \u274c \u274c \u274c \u274c Duration Implicit \u274c \u274c \u274c \u274c \u274c - \u274c \u274c \u274c Boolean Implicit \u274c \u274c \u274c \u274c \u274c \u274c - \u274c \u274c Item Implicit \u274c \u274c \u274c \u274c \u274c \u274c \u274c - \u274c Subcategory Implicit \u274c \u274c \u274c \u274c \u274c \u274c \u274c \u274c - <p>Legend: - Implicit: Automatic conversion when needed - Explicit: Requires explicit cast operator - \u274c: Not possible</p>"},{"location":"information-model/data-types/#casting-examples","title":"Casting Examples","text":"<pre><code>cast(100, \"string\")           # \"100\"\ncast(\"3.14\", number)          # 3.14\ncast(5, number)               # 5.0 (implicit)\ncast(\"2023-12-31\", date)      # #2023-12-31#\n</code></pre>"},{"location":"information-model/data-types/#null-handling","title":"Null Handling","text":"<p>All data types support the special value <code>null</code>:</p>"},{"location":"information-model/data-types/#universal-null","title":"Universal Null","text":"<ul> <li>Every data type includes <code>null</code> as a valid value</li> <li>Represents \"no value\", \"absence of value\", or \"missing value\"</li> <li>The same <code>null</code> value exists across all types</li> </ul>"},{"location":"information-model/data-types/#string-special-case","title":"String Special Case","text":"<p>For String data type, <code>null</code> is equivalent to empty string: <pre><code>null = \"\"         # true in string context\n</code></pre></p>"},{"location":"information-model/data-types/#three-valued-logic","title":"Three-Valued Logic","text":"<p>Boolean operations with null follow three-valued logic: <pre><code>true and null     # null\nfalse or null     # null\nnull = null       # null\n</code></pre></p>"},{"location":"information-model/data-types/#interval-arithmetic","title":"Interval Arithmetic","text":"<p>Numeric types (Number and Integer) support interval arithmetic:</p>"},{"location":"information-model/data-types/#interval-representation","title":"Interval Representation","text":"<ul> <li>Center: The input value</li> <li>Radius: Calculated as 10^(-p)/2 where p is precision</li> <li>Range: [center - radius, center + radius]</li> </ul>"},{"location":"information-model/data-types/#interval-operations","title":"Interval Operations","text":"<p>Operations on intervals follow specific rules: - Addition: centers add, radii add - Subtraction: centers subtract, radii add - Multiplication: complex radius calculation - Comparison: based on interval overlap</p>"},{"location":"information-model/data-types/#example","title":"Example","text":"<pre><code># Value 100 with precision 1 becomes interval 100 \u00b1 0.05\n# Range: [99.95, 100.05]\n</code></pre>"},{"location":"information-model/data-types/#writing-scalar-literals","title":"Writing Scalar Literals","text":""},{"location":"information-model/data-types/#string-literals","title":"String Literals","text":"<pre><code>\"Double quotes\"\n'Single quotes'\n\"String with spaces and symbols: @#$%\"\n\"\"                    # Empty string\n</code></pre>"},{"location":"information-model/data-types/#numeric-literals","title":"Numeric Literals","text":"<pre><code>42                    # Integer\n-17                   # Negative integer\n3.14159              # Number\n-0.5                 # Negative number\n</code></pre>"},{"location":"information-model/data-types/#boolean-literals","title":"Boolean Literals","text":"<pre><code>true\nfalse\n</code></pre>"},{"location":"information-model/data-types/#temporal-literals","title":"Temporal Literals","text":"<pre><code>#2023-12-31#         # Date\n#2023Q4#             # Time period (quarter)\n#2023M12#            # Time period (month)\n#P1Y6M#              # Duration (1 year 6 months)\n#2021-01-01/2021-12-31# # Time interval\n</code></pre>"},{"location":"information-model/data-types/#dpm-object-literals","title":"DPM Object Literals","text":"<pre><code>[item, eba_RT:x11]\n[subcategory, eba_CU:iso_currencies]\n</code></pre> <p>Type Design Philosophy</p> <p>The DPM-XL type system prioritizes:</p> <ol> <li>Operational Distinctness - Types exist only when they behave differently</li> <li>Business Relevance - Types map to concepts business users understand  </li> <li>Implementation Efficiency - Simple enough for efficient execution</li> <li>Regulatory Completeness - Covers all scenarios needed for regulatory reporting</li> </ol>"},{"location":"information-model/operations/","title":"Operations","text":"<p>Operations form the fundamental building blocks of DPM-XL, defining how expressions are structured and executed. Understanding operations is essential for both writing expressions and implementing execution engines.</p>"},{"location":"information-model/operations/#conceptual-structure","title":"Conceptual Structure","text":"<p>Every operation in DPM-XL follows a consistent conceptual structure:</p> graph TD     A[DPM Operations] --&gt; B[Scripts]     B --&gt; C[Operations]     C --&gt; D[Operators]     C --&gt; E[Operands]     C --&gt; F[Results]     D --&gt; G[Apply to Operands]     G --&gt; F     E --&gt; G     F --&gt; H[DPM EL Artifacts]     E --&gt; H      style A fill:#e3f2fd     style C fill:#f3e5f5     style F fill:#e8f5e8"},{"location":"information-model/operations/#core-components","title":"Core Components","text":""},{"location":"information-model/operations/#scripts","title":"Scripts","text":"<p>Scripts are complete computer programs composed of one or more operations. They represent: - A complete validation or calculation routine - A runtime execution context - A collection of related operations</p>"},{"location":"information-model/operations/#operations_1","title":"Operations","text":"<p>Operations are individual expressions within a script that: - Use input operands and operators to produce results - Follow syntactical rules of the language - Combine operands using operators in a specific order - Generate outputs that can be used by other operations</p>"},{"location":"information-model/operations/#operators","title":"Operators","text":"<p>Operators specify the type of operation to be performed: - Take operands as input (with rare exceptions like current time) - Apply transformations or calculations - Generate outputs for use in other operations - Can be nested (output of one becomes input to another)</p>"},{"location":"information-model/operations/#operands","title":"Operands","text":"<p>Operands are the input data for operations: - Specific artifacts from the DPM Expression Language - Can be scalars, scalar sets, or recordsets - Referenced within expressions as input values - May come from data selections or previous operation results</p>"},{"location":"information-model/operations/#results","title":"Results","text":"<p>Results are the outputs produced by operations: - Also specific artifacts from the DPM Expression Language - Can be scalars, scalar sets, or recordsets - May be used as operands in subsequent operations - Represent the final or intermediate outcomes of calculations</p>"},{"location":"information-model/operations/#expression-composition","title":"Expression Composition","text":"<p>Operations compose operands and operators according to specific rules:</p>"},{"location":"information-model/operations/#finite-combinations","title":"Finite Combinations","text":"<p>Expressions are finite combinations of symbols that are well-formed according to syntactical rules.</p>"},{"location":"information-model/operations/#ordered-application","title":"Ordered Application","text":"<p>Operators are applied to operands in a specific order determined by: - Operator precedence rules - Explicit grouping (parentheses) - Left-to-right evaluation for same precedence</p>"},{"location":"information-model/operations/#symbol-designation","title":"Symbol Designation","text":"<p>The symbols in an expression designate: - Operators: What operation to perform - Operands: What data to operate on - Order: How operations should be sequenced</p>"},{"location":"information-model/operations/#operation-examples","title":"Operation Examples","text":""},{"location":"information-model/operations/#simple-operation","title":"Simple Operation","text":"<p><pre><code>{F_01.01, r0010, c0010} + {F_01.01, r0020, c0010}\n</code></pre> - Operands: Two data selections - Operator: Addition (<code>+</code>) - Result: Sum of the two selected values</p>"},{"location":"information-model/operations/#complex-operation","title":"Complex Operation","text":"<p><pre><code>sum({F_20.05, r0020-0030, c0010} group by CNT) &gt; 1000\n</code></pre> - Operands: Data selection and literal value - Operators: Aggregation (<code>sum</code>), comparison (<code>&gt;</code>) - Result: Boolean indicating if condition is met</p>"},{"location":"information-model/operations/#nested-operations","title":"Nested Operations","text":"<p><pre><code>max({F_01.01, r0010, c0010}, \n    min({F_01.01, r0020, c0010}, {F_01.01, r0030, c0010}))\n</code></pre> - Inner operation: <code>min()</code> function - Outer operation: <code>max()</code> function using inner result - Nesting: Output of <code>min</code> becomes input to <code>max</code></p>"},{"location":"information-model/operations/#operation-flow","title":"Operation Flow","text":"<p>The execution of operations follows a well-defined flow:</p> graph LR     A[Select Operands] --&gt; B[Apply Operator]     B --&gt; C[Generate Result]     C --&gt; D[Result Available for Use]      style A fill:#e3f2fd     style B fill:#f3e5f5     style C fill:#e8f5e8"},{"location":"information-model/operations/#step-1-operand-selection","title":"Step 1: Operand Selection","text":"<ul> <li>Identify input data through selection expressions</li> <li>Retrieve values from data sources</li> <li>Validate operand types and structures</li> </ul>"},{"location":"information-model/operations/#step-2-operator-application","title":"Step 2: Operator Application","text":"<ul> <li>Check operator constraints and requirements</li> <li>Apply operator logic to operands</li> <li>Handle special cases (nulls, empty sets, etc.)</li> </ul>"},{"location":"information-model/operations/#step-3-result-generation","title":"Step 3: Result Generation","text":"<ul> <li>Produce output according to operator semantics</li> <li>Ensure result type matches operator specification</li> <li>Make result available for subsequent operations</li> </ul>"},{"location":"information-model/operations/#operator-characteristics","title":"Operator Characteristics","text":""},{"location":"information-model/operations/#input-flexibility","title":"Input Flexibility","text":"<p>Most operators take operands as input, but some exceptions exist: - Current time operators: Generate temporal values without input - Constant generators: Produce predefined values - Context operators: Access execution environment information</p>"},{"location":"information-model/operations/#output-usage","title":"Output Usage","text":"<p>Operator outputs can be: - Final results: Terminal values for validation or calculation - Intermediate values: Inputs for subsequent operations - Side effects: Actions that don't produce direct outputs</p>"},{"location":"information-model/operations/#nesting-capability","title":"Nesting Capability","text":"<p>Operations support arbitrary nesting depth: - Inner operations execute first - Results flow outward through nesting levels - Type compatibility must be maintained across nesting boundaries</p>"},{"location":"information-model/operations/#validation-and-constraints","title":"Validation and Constraints","text":"<p>Operations must satisfy several constraints:</p>"},{"location":"information-model/operations/#syntactic-validity","title":"Syntactic Validity","text":"<ul> <li>Must follow grammar rules</li> <li>Proper operator usage</li> <li>Valid operand references</li> </ul>"},{"location":"information-model/operations/#type-compatibility","title":"Type Compatibility","text":"<ul> <li>Operands must match operator requirements</li> <li>Type casting rules apply where appropriate</li> <li>Result types must be predictable</li> </ul>"},{"location":"information-model/operations/#semantic-correctness","title":"Semantic Correctness","text":"<ul> <li>Operations must make business sense</li> <li>Data references must exist</li> <li>Constraints must be satisfiable</li> </ul> <p>Implementation Insight</p> <p>Operations provide the execution model for DPM-XL engines. Each operation can be:</p> <ul> <li>Parsed into constituent parts (operators, operands)</li> <li>Validated for correctness and type safety</li> <li>Executed to produce deterministic results</li> <li>Optimized through caching and pre-computation</li> </ul>"},{"location":"information-model/artifacts/","title":"Language Artifacts","text":"<p>Language artifacts are the fundamental data structures that DPM Expression Language operates on and produces as results. Understanding these artifacts is crucial for both writing expressions and implementing execution engines.</p>"},{"location":"information-model/artifacts/#the-three-artifact-types","title":"The Three Artifact Types","text":"<p>DPM-XL calculations can operate on and generate three distinct types of artifacts:</p> graph TD     A[DPM EL Artifacts] --&gt; B[Scalars]     A --&gt; C[Scalar Sets]     A --&gt; D[Recordsets]      B --&gt; B1[Individual Values]     B --&gt; B2[Specific Data Type]      C --&gt; C1[Collections of Scalars]     C --&gt; C2[Same Data Type]      D --&gt; D1[Tabular Structures]     D --&gt; D2[Complex Components]      style A fill:#e3f2fd     style B fill:#f3e5f5     style C fill:#e8f5e8     style D fill:#fff3e0"},{"location":"information-model/artifacts/#artifact-hierarchy","title":"Artifact Hierarchy","text":"<p>The artifacts form a conceptual hierarchy from simple to complex:</p>"},{"location":"information-model/artifacts/#level-1-scalars","title":"Level 1: Scalars","text":"<p>The simplest artifacts - individual values with specific data types. - Foundation for all other artifacts - Direct representation of single data points - Support all DPM data types</p>"},{"location":"information-model/artifacts/#level-2-scalar-sets","title":"Level 2: Scalar Sets","text":"<p>Collections of scalar values sharing the same data type. - Used primarily with membership operations - Enable set-based comparisons and validations - Maintain type homogeneity</p>"},{"location":"information-model/artifacts/#level-3-recordsets","title":"Level 3: Recordsets","text":"<p>Complex tabular data structures with rich component structure. - Most powerful and flexible artifact type - Support multi-dimensional data organization - Enable complex analytical operations</p>"},{"location":"information-model/artifacts/#key-characteristics","title":"Key Characteristics","text":""},{"location":"information-model/artifacts/#type-consistency","title":"Type Consistency","text":"<p>All artifacts maintain strict data type consistency: - Scalars have a single, well-defined type - Scalar sets contain only values of the same type - Recordset components are individually typed</p>"},{"location":"information-model/artifacts/#operational-completeness","title":"Operational Completeness","text":"<p>The artifact system supports all required regulatory operations: - Individual value calculations (scalars) - Membership and set operations (scalar sets) - Aggregation and analytical operations (recordsets)</p>"},{"location":"information-model/artifacts/#composability","title":"Composability","text":"<p>Artifacts can be combined and transformed: - Operations can take multiple artifact types as input - Results can be any artifact type - Complex workflows through artifact transformation</p>"},{"location":"information-model/artifacts/#usage-patterns","title":"Usage Patterns","text":"<p>Different artifacts serve different purposes in typical expressions:</p>"},{"location":"information-model/artifacts/#scalars-for-constants-and-results","title":"Scalars for Constants and Results","text":"<p><pre><code>{F_01.01, r0010, c0010} &gt; 1000\n</code></pre> - <code>1000</code> is a scalar constant - Comparison result is a scalar boolean</p>"},{"location":"information-model/artifacts/#scalar-sets-for-membership","title":"Scalar Sets for Membership","text":"<p><pre><code>{F_40.01, c0015}[where TYC in {\"LEI\", \"ISIN\"}]\n</code></pre> - <code>{\"LEI\", \"ISIN\"}</code> is a scalar set - Used to filter recordset based on membership</p>"},{"location":"information-model/artifacts/#recordsets-for-complex-data","title":"Recordsets for Complex Data","text":"<p><pre><code>sum({F_20.05, r0020-0030, c0010} group by CNT)\n</code></pre> - Selection produces a recordset - Aggregation operates on recordset structure</p>"},{"location":"information-model/artifacts/#transformation-between-artifacts","title":"Transformation Between Artifacts","text":"<p>Operations can transform artifacts between types:</p> graph LR     A[Recordset] --&gt; |Aggregation| B[Scalar]     C[Scalar] --&gt; |Broadcast| D[Recordset]     E[Recordset] --&gt; |Filter| F[Recordset]     G[Scalar Set] --&gt; |Selection| H[Recordset]      style A fill:#fff3e0     style B fill:#f3e5f5     style C fill:#f3e5f5     style D fill:#fff3e0     style E fill:#fff3e0     style F fill:#fff3e0     style G fill:#e8f5e8     style H fill:#fff3e0"},{"location":"information-model/artifacts/#common-transformations","title":"Common Transformations","text":"<ul> <li>Recordset \u2192 Scalar: Aggregation operations (<code>sum</code>, <code>count</code>, <code>max</code>)</li> <li>Scalar \u2192 Recordset: Broadcasting in binary operations</li> <li>Recordset \u2192 Recordset: Filtering, transformation, projection</li> <li>Scalar Set \u2192 Recordset: Through membership filtering</li> </ul>"},{"location":"information-model/artifacts/#memory-and-performance-considerations","title":"Memory and Performance Considerations","text":"<p>Different artifacts have different computational characteristics:</p>"},{"location":"information-model/artifacts/#scalars","title":"Scalars","text":"<ul> <li>Minimal memory footprint</li> <li>Fast operations</li> <li>Direct value access</li> </ul>"},{"location":"information-model/artifacts/#scalar-sets","title":"Scalar Sets","text":"<ul> <li>Moderate memory usage</li> <li>Set operations may require sorting/hashing</li> <li>Used primarily for lookup operations</li> </ul>"},{"location":"information-model/artifacts/#recordsets","title":"Recordsets","text":"<ul> <li>Potentially large memory usage</li> <li>Complex operations requiring joins and grouping</li> <li>May require optimization for large datasets</li> </ul>"},{"location":"information-model/artifacts/#design-principles","title":"Design Principles","text":"<p>The artifact system follows several key design principles:</p>"},{"location":"information-model/artifacts/#minimal-complexity","title":"Minimal Complexity","text":"<p>Only the necessary artifact types are provided - no artificial complexity.</p>"},{"location":"information-model/artifacts/#maximum-expressiveness","title":"Maximum Expressiveness","text":"<p>The three types together can express all required regulatory calculations.</p>"},{"location":"information-model/artifacts/#type-safety","title":"Type Safety","text":"<p>Strong typing prevents errors and enables optimization.</p>"},{"location":"information-model/artifacts/#business-alignment","title":"Business Alignment","text":"<p>Artifacts map naturally to business concepts (values, lists, tables).</p> <p>Implementation Strategy</p> <p>When implementing DPM-XL engines:</p> <ol> <li>Start with Scalars - Implement the basic value system first</li> <li>Add Scalar Sets - Implement set operations and membership</li> <li>Build Recordsets - Implement the full tabular structure</li> <li>Optimize Later - Get correctness first, then optimize for performance</li> </ol>"},{"location":"information-model/artifacts/recordsets/","title":"Recordsets","text":"<p>Recordsets are the most complex and powerful language artifacts in DPM-XL, representing two-dimensional labeled data structures similar to relational tables or data frames. They enable sophisticated analytical operations and multi-dimensional data processing.</p>"},{"location":"information-model/artifacts/recordsets/#definition","title":"Definition","text":"<p>Recordsets are collections of Records that share the same Structure. They are two-dimensional labeled data structures (tabular) that can be assimilated to Relational Tables or Data Frames.</p>"},{"location":"information-model/artifacts/recordsets/#core-structure","title":"Core Structure","text":"graph TD     A[Recordset] --&gt; B[Structure]     A --&gt; C[Records]     B --&gt; D[Components]     D --&gt; E[Key]     D --&gt; F[Fact]     D --&gt; G[Attribute]     E --&gt; H[Standard]     E --&gt; I[DPM]     H --&gt; J[Row Key]     H --&gt; K[Column Key]     H --&gt; L[Sheet Key]      style A fill:#fff3e0     style B fill:#e3f2fd     style C fill:#f3e5f5     style E fill:#e8f5e8"},{"location":"information-model/artifacts/recordsets/#structure-components","title":"Structure Components","text":"<p>The structure of a recordset consists of three types of components:</p>"},{"location":"information-model/artifacts/recordsets/#key-components","title":"Key Components","text":"<p>Provide unique identification for each record: - Combination of key component values uniquely identifies each record - Used for joining and matching operations - Can be Standard or DPM-specific</p>"},{"location":"information-model/artifacts/recordsets/#fact-component","title":"Fact Component","text":"<p>Contains the primary measured value: - Every recordset has exactly one fact component - Named \"f\" by convention - Contains the main data of interest</p>"},{"location":"information-model/artifacts/recordsets/#attribute-components","title":"Attribute Components","text":"<p>Provide additional metadata about the fact value: - Optional components providing context - Can include precision, currency, status codes, etc. - Support rich data annotation</p>"},{"location":"information-model/artifacts/recordsets/#component-details","title":"Component Details","text":""},{"location":"information-model/artifacts/recordsets/#key-components_1","title":"Key Components","text":"<p>Key components come in two varieties:</p>"},{"location":"information-model/artifacts/recordsets/#standard-key-components","title":"Standard Key Components","text":""},{"location":"information-model/artifacts/recordsets/#dpm-xl-standard-keys","title":"DPM-XL Standard Keys","text":"<ul> <li>Row Key (<code>r</code>): Identifies the row ordinate from a Report Table</li> <li>Column Key (<code>c</code>): Identifies the column ordinate from a Report Table</li> <li>Sheet Key (<code>s</code>): Identifies the sheet ordinate from a Report Table</li> </ul>"},{"location":"information-model/artifacts/recordsets/#dpm-ml-standard-keys","title":"DPM-ML Standard Keys","text":"<ul> <li>X Index: Abstract index for variable matching</li> <li>Y Index: Abstract index for variable matching  </li> <li>Z Index: Abstract index for variable matching</li> </ul>"},{"location":"information-model/artifacts/recordsets/#dpm-key-components","title":"DPM Key Components","text":"<ul> <li>Specific to how data is defined in the DPM</li> <li>One component per Key Variable associated to selected Variables</li> <li>Named using the Code of the Property associated to the Key Variable</li> <li>Data type matches the associated Property or Metric</li> </ul>"},{"location":"information-model/artifacts/recordsets/#fact-component_1","title":"Fact Component","text":"<ul> <li>Mandatory single component named \"f\"</li> <li>Data type depends on the selected Variables</li> <li>Contains the primary measurement or value</li> <li>When a Key Variable is selected, appears in both Key and Fact components</li> </ul>"},{"location":"information-model/artifacts/recordsets/#attribute-components_1","title":"Attribute Components","text":"<ul> <li>Provide additional information about the Fact value</li> <li>One component per Property or Metric associated to Attribute Variables</li> <li>Named using the Code of the Property associated to the Attribute Variable</li> <li>Support metadata like precision, currency, validation status</li> </ul>"},{"location":"information-model/artifacts/recordsets/#record-structure","title":"Record Structure","text":"<p>Each record in a recordset contains: - Values for all Key Components: Providing unique identification - Value for the Fact Component: The primary data - Values for Attribute Components: Additional metadata</p>"},{"location":"information-model/artifacts/recordsets/#unique-identification","title":"Unique Identification","text":"<p>Each record is individually identified by the combination of values for its Key Components.</p>"},{"location":"information-model/artifacts/recordsets/#special-cases","title":"Special Cases","text":"<ul> <li>No Key Components: Recordset behaves like a Scalar</li> <li>No Records: Empty recordset is valid and maintains structure</li> </ul>"},{"location":"information-model/artifacts/recordsets/#creation-patterns","title":"Creation Patterns","text":"<p>Recordsets arise from several types of data selections:</p>"},{"location":"information-model/artifacts/recordsets/#open-variable-selections","title":"Open Variable Selections","text":"<p>Select variables associated with keys, creating multi-record recordsets: <pre><code>{F_40.01, c0031}  # Selects all values for an open variable\n</code></pre></p>"},{"location":"information-model/artifacts/recordsets/#variable-set-selections","title":"Variable Set Selections","text":"<p>Select multiple variables, creating recordsets with standard key components: <pre><code>{F_20.05, r0020-0030, c0010}  # Multiple rows create row key component\n</code></pre></p>"},{"location":"information-model/artifacts/recordsets/#closed-variable-selections","title":"Closed Variable Selections","text":"<p>Select single specific variables: <pre><code>{F_01.01, r0010, c0010}  # Single cell, behaves like scalar\n</code></pre></p>"},{"location":"information-model/artifacts/recordsets/#example-structures","title":"Example Structures","text":""},{"location":"information-model/artifacts/recordsets/#simple-recordset","title":"Simple Recordset","text":"<p><pre><code>| CNT | f   |\n|-----|-----|\n| ES  | 100 |\n| PT  | 200 |\n| DE  | 300 |\n</code></pre> - Key Component: CNT (country) - Fact Component: f (value) - 3 records</p>"},{"location":"information-model/artifacts/recordsets/#complex-recordset","title":"Complex Recordset","text":"<p><pre><code>| LIN    | TYC  | r    | f     | precision |\n|--------|------|------|-------|-----------|\n| 123456 | LEI  | 0020 | 1000  | 1         |\n| 123456 | ISIN | 0020 | 2000  | 1         |\n| 789012 | LEI  | 0030 | 3000  | 2         |\n</code></pre> - Key Components: LIN, TYC, r - Fact Component: f - Attribute Component: precision - 3 records</p>"},{"location":"information-model/artifacts/recordsets/#operations-on-recordsets","title":"Operations on Recordsets","text":""},{"location":"information-model/artifacts/recordsets/#filtering","title":"Filtering","text":"<p>Select subset of records based on conditions: <pre><code>{F_40.01, c0031}[where TYC = \"LEI\"]\n</code></pre></p>"},{"location":"information-model/artifacts/recordsets/#aggregation","title":"Aggregation","text":"<p>Combine multiple records into summary values: <pre><code>sum({F_20.05, r0020-0030, c0010} group by CNT)\n</code></pre></p>"},{"location":"information-model/artifacts/recordsets/#joining","title":"Joining","text":"<p>Combine recordsets based on common keys: <pre><code>{F_01.01, c0010} + {F_01.01, c0020}  # Inner join on common keys\n</code></pre></p>"},{"location":"information-model/artifacts/recordsets/#transformation","title":"Transformation","text":"<p>Modify structure or values: <pre><code>{F_40.01, c0031}[rename TYC to TypeCode]\n</code></pre></p>"},{"location":"information-model/artifacts/recordsets/#binary-operations-with-recordsets","title":"Binary Operations with Recordsets","text":"<p>When recordsets are used in binary operations, they must satisfy compatibility constraints:</p>"},{"location":"information-model/artifacts/recordsets/#exact-same-keys","title":"Exact Same Keys","text":"<p>Both recordsets have identical key components: <pre><code>{F_01.01, c0010} + {F_01.01, c0020}\n</code></pre></p>"},{"location":"information-model/artifacts/recordsets/#subset-keys","title":"Subset Keys","text":"<p>One recordset's keys are a superset of the other's: <pre><code>{F_40.01, c0110} &gt;= {F_40.02, c0060}\n# F_40.02 has additional key components\n</code></pre></p>"},{"location":"information-model/artifacts/recordsets/#inner-join-semantics","title":"Inner Join Semantics","text":"<p>Operations perform inner joins on common key components.</p>"},{"location":"information-model/artifacts/recordsets/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"information-model/artifacts/recordsets/#memory-usage","title":"Memory Usage","text":"<ul> <li>Proportional to number of records \u00d7 number of components</li> <li>Structure overhead is minimal</li> <li>Large recordsets may require optimization</li> </ul>"},{"location":"information-model/artifacts/recordsets/#operation-complexity","title":"Operation Complexity","text":"<ul> <li>Filtering: O(n) where n = number of records</li> <li>Aggregation: O(n) to O(n log n) depending on grouping</li> <li>Joining: O(n \u00d7 m) to O(n + m) with proper indexing</li> </ul>"},{"location":"information-model/artifacts/recordsets/#optimization-opportunities","title":"Optimization Opportunities","text":"<ul> <li>Indexing: On key components for fast joins</li> <li>Columnar storage: For analytical operations</li> <li>Lazy evaluation: For chained operations</li> </ul>"},{"location":"information-model/artifacts/recordsets/#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"information-model/artifacts/recordsets/#structure-definition","title":"Structure Definition","text":"<pre><code>class RecordsetStructure {\n    List&lt;Component&gt; keyComponents;\n    Component factComponent;\n    List&lt;Component&gt; attributeComponents;\n}\n\nclass Component {\n    String name;\n    DataType dataType;\n    ComponentRole role;  // KEY, FACT, ATTRIBUTE\n}\n</code></pre>"},{"location":"information-model/artifacts/recordsets/#record-storage","title":"Record Storage","text":"<pre><code>class Recordset {\n    RecordsetStructure structure;\n    List&lt;Record&gt; records;\n\n    Record findByKeys(Map&lt;String, Value&gt; keyValues);\n    List&lt;Record&gt; filter(Predicate&lt;Record&gt; condition);\n    Recordset join(Recordset other, JoinType type);\n}\n</code></pre>"},{"location":"information-model/artifacts/recordsets/#efficient-access-patterns","title":"Efficient Access Patterns","text":"<ul> <li>Primary index: On all key components combined</li> <li>Secondary indexes: On individual key components</li> <li>Column access: For analytical operations</li> </ul>"},{"location":"information-model/artifacts/recordsets/#special-behaviors","title":"Special Behaviors","text":""},{"location":"information-model/artifacts/recordsets/#scalar-like-recordsets","title":"Scalar-like Recordsets","text":"<p>Recordsets with no key components behave like scalars: - Single record (or no records) - Operations treat them as scalar values - Can be used wherever scalars are expected</p>"},{"location":"information-model/artifacts/recordsets/#empty-recordsets","title":"Empty Recordsets","text":"<p>Valid recordsets with no records: - Maintain structure definition - Aggregations return appropriate empty values (null, 0, etc.) - Joins produce empty results</p>"},{"location":"information-model/artifacts/recordsets/#key-variable-selection","title":"Key Variable Selection","text":"<p>When selecting key variables, values appear in both key and fact components: <pre><code>| LIN    | TYC  | f    |\n|--------|------|------|\n| 123456 | LEI  | LEI  |\n| 123456 | ISIN | ISIN |\n</code></pre> This enables calculations on key values while maintaining record identity.</p>"},{"location":"information-model/artifacts/recordsets/#common-patterns","title":"Common Patterns","text":""},{"location":"information-model/artifacts/recordsets/#country-based-aggregation","title":"Country-based Aggregation","text":"<pre><code>sum({F_20.05, r0020-0030, c0010} group by CNT)\n</code></pre>"},{"location":"information-model/artifacts/recordsets/#cross-table-validation","title":"Cross-table Validation","text":"<pre><code>{F_01.01, r0010, c0010} = sum({F_20.05, r0020-0030, c0010})\n</code></pre>"},{"location":"information-model/artifacts/recordsets/#conditional-processing","title":"Conditional Processing","text":"<pre><code>if sum({F_01.01, r0010-0020, c0010}) &gt; 1000 \nthen {F_01.01, r0030, c0010} \nelse 0\n</code></pre> <p>Recordset Design Philosophy</p> <p>Recordsets bridge the gap between business concepts (tables, reports) and computational needs (structured data processing). They maintain the familiar tabular metaphor while enabling sophisticated analytical operations.</p>"},{"location":"information-model/artifacts/scalar-sets/","title":"Scalar Sets","text":"<p>Scalar Sets are collections of scalar values that share the same data type. They are primarily used for membership operations and set-based comparisons in DPM-XL expressions.</p>"},{"location":"information-model/artifacts/scalar-sets/#definition","title":"Definition","text":"<p>Scalar Sets are sets of Scalar values defined on the same Data Type.</p> <p>Key characteristics: - Homogeneous: All values must be of the same data type - Unordered: No inherent ordering (though may be sorted for efficiency) - Unique: Typically contain unique values (set semantics) - Finite: Always contain a finite number of elements</p>"},{"location":"information-model/artifacts/scalar-sets/#primary-usage","title":"Primary Usage","text":"<p>Scalar Sets are typically used with the in operator for membership testing:</p> <pre><code>{F_40.01, c0015}[where TYC in {\"LEI\", \"ISIN\", \"MIC\"}]\n#                              ^^^^^^^^^^^^^^^^^^^^ Scalar set\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#syntax-and-creation","title":"Syntax and Creation","text":""},{"location":"information-model/artifacts/scalar-sets/#literal-sets","title":"Literal Sets","text":"<p>Created using curly brace syntax with comma-separated values:</p> <pre><code>{1, 2, 3, 4, 5}              # Integer set\n{\"ES\", \"PT\", \"DE\", \"FR\"}     # String set\n{true, false}                # Boolean set\n{#2023Q1#, #2023Q2#}         # Time period set\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#type-consistency","title":"Type Consistency","text":"<p>All elements must be of the same type: <pre><code>{1, 2, 3}           # \u2713 Valid: all integers\n{\"A\", \"B\", \"C\"}     # \u2713 Valid: all strings\n{1, \"A\", true}      # \u2717 Invalid: mixed types\n</code></pre></p>"},{"location":"information-model/artifacts/scalar-sets/#empty-sets","title":"Empty Sets","text":"<p>Empty sets are valid and type-neutral: <pre><code>{}                  # Empty set (type determined by context)\n</code></pre></p>"},{"location":"information-model/artifacts/scalar-sets/#data-type-support","title":"Data Type Support","text":"<p>Scalar Sets can be created for any DPM data type:</p>"},{"location":"information-model/artifacts/scalar-sets/#numeric-sets","title":"Numeric Sets","text":"<pre><code>{100, 200, 300}                    # Integer set\n{1.5, 2.7, 3.14159}               # Number set\n{-10, 0, 10}                      # Mixed positive/negative integers\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#string-sets","title":"String Sets","text":"<pre><code>{\"Active\", \"Inactive\", \"Pending\"}  # Status codes\n{\"EUR\", \"USD\", \"GBP\"}             # Currency codes\n{\"High\", \"Medium\", \"Low\"}         # Risk categories\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#temporal-sets","title":"Temporal Sets","text":"<pre><code>{#2023Q1#, #2023Q2#, #2023Q3#, #2023Q4#}    # Quarterly periods\n{#2023-01-01#, #2023-06-30#, #2023-12-31#}  # Specific dates\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#category-item-sets","title":"Category Item Sets","text":"<pre><code>{[item, \"code1\"], [item, \"code2\"], [item, \"code3\"]}  # Category items\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#operations-with-scalar-sets","title":"Operations with Scalar Sets","text":""},{"location":"information-model/artifacts/scalar-sets/#membership-testing","title":"Membership Testing","text":"<p>The primary operation is membership testing with <code>in</code>: <pre><code>\"EUR\" in {\"EUR\", \"USD\", \"GBP\"}     # true\n100 in {200, 300, 400}             # false\n</code></pre></p>"},{"location":"information-model/artifacts/scalar-sets/#negated-membership","title":"Negated Membership","text":"<p>Test for non-membership: <pre><code>not (\"JPY\" in {\"EUR\", \"USD\", \"GBP\"})  # true\n</code></pre></p>"},{"location":"information-model/artifacts/scalar-sets/#with-recordsets","title":"With Recordsets","text":"<p>Most commonly used to filter recordsets: <pre><code>{F_20.05, r0020-0030, c0010}[where CNT in {\"ES\", \"PT\", \"DE\"}]\n</code></pre></p>"},{"location":"information-model/artifacts/scalar-sets/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":""},{"location":"information-model/artifacts/scalar-sets/#dynamic-filtering","title":"Dynamic Filtering","text":"<pre><code># Filter records based on predefined country set\nwith {F_20.05}:\n    {r0020-0030, c0010}[where CNT in {\"ES\", \"PT\", \"IT\", \"FR\"}]\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#multi-condition-filtering","title":"Multi-Condition Filtering","text":"<pre><code># Multiple set-based conditions\n{F_40.01, c0031}[where \n    TYC in {\"LEI\", \"ISIN\"} and \n    STC in {\"Active\", \"Inactive\"}\n]\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#exclusion-patterns","title":"Exclusion Patterns","text":"<pre><code># Select records NOT in specified set\n{F_20.05, r0020-0030, c0010}[where not (CNT in {\"EX1\", \"EX2\"})]\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#null-handling","title":"Null Handling","text":"<p>Scalar Sets can contain null values:</p> <pre><code>{null, \"A\", \"B\"}     # Set containing null\nnull in {null, 1, 2} # true\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#null-propagation","title":"Null Propagation","text":"<pre><code>null in {\"A\", \"B\"}   # null (three-valued logic)\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#performance-considerations","title":"Performance Considerations","text":""},{"location":"information-model/artifacts/scalar-sets/#set-size","title":"Set Size","text":"<ul> <li>Small sets (&lt; 10 elements): Linear search is efficient</li> <li>Large sets: May require hash-based implementation</li> <li>Very large sets: Consider alternative approaches</li> </ul>"},{"location":"information-model/artifacts/scalar-sets/#type-optimization","title":"Type Optimization","text":"<p>Different data types may have different optimal implementations: - Integers: Bit sets for small ranges - Strings: Hash sets or tries - Temporal: Range-based optimizations</p>"},{"location":"information-model/artifacts/scalar-sets/#membership-testing_1","title":"Membership Testing","text":"<p>Frequent membership testing benefits from: - Hash-based lookup structures - Sorted arrays with binary search - Bloom filters for very large sets</p>"},{"location":"information-model/artifacts/scalar-sets/#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"information-model/artifacts/scalar-sets/#storage-strategy","title":"Storage Strategy","text":"<pre><code>class ScalarSet {\n    DataType elementType;\n    Set&lt;Value&gt; values;      // Hash set for O(1) lookup\n\n    boolean contains(Value v) {\n        return values.contains(v);\n    }\n}\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#type-validation","title":"Type Validation","text":"<p>Enforce type homogeneity: <pre><code>void addValue(Value v) {\n    if (elementType == null) {\n        elementType = v.getType();\n    } else if (!v.getType().isCompatibleWith(elementType)) {\n        throw new TypeError(\"Incompatible type in scalar set\");\n    }\n    values.add(v);\n}\n</code></pre></p>"},{"location":"information-model/artifacts/scalar-sets/#optimization-opportunities","title":"Optimization Opportunities","text":"<ul> <li>Immutable sets: Can be pre-optimized and cached</li> <li>Static sets: Compile-time optimization for literal sets</li> <li>Set intersection: Optimize multiple membership tests</li> <li>Range sets: Special handling for numeric ranges</li> </ul>"},{"location":"information-model/artifacts/scalar-sets/#common-patterns","title":"Common Patterns","text":""},{"location":"information-model/artifacts/scalar-sets/#regulatory-code-lists","title":"Regulatory Code Lists","text":"<pre><code># Country codes for EU member states\n{\"AT\", \"BE\", \"BG\", \"HR\", \"CY\", \"CZ\", \"DK\", \"EE\", \"FI\", \"FR\", \n \"DE\", \"GR\", \"HU\", \"IE\", \"IT\", \"LV\", \"LT\", \"LU\", \"MT\", \"NL\", \n \"PL\", \"PT\", \"RO\", \"SK\", \"SI\", \"ES\", \"SE\"}\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#asset-class-categories","title":"Asset Class Categories","text":"<pre><code># High-risk asset classes\n{\"Derivatives\", \"Structured Products\", \"Commodities\", \"Alternative Investments\"}\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#reporting-periods","title":"Reporting Periods","text":"<pre><code># Quarterly reporting periods for current year\n{#2023Q1#, #2023Q2#, #2023Q3#, #2023Q4#}\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#status-codes","title":"Status Codes","text":"<pre><code># Valid loan statuses\n{\"Performing\", \"Non-performing\", \"Defaulted\", \"Written-off\"}\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#error-conditions","title":"Error Conditions","text":""},{"location":"information-model/artifacts/scalar-sets/#type-mismatch","title":"Type Mismatch","text":"<pre><code>{1, 2, \"three\"}     # Error: mixed integer and string types\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#invalid-values","title":"Invalid Values","text":"<pre><code>{#2023-02-30#}      # Error: invalid date in set\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#malformed-syntax","title":"Malformed Syntax","text":"<pre><code>{1, 2, 3,}          # Error: trailing comma (depending on implementation)\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#interaction-with-subcategories","title":"Interaction with Subcategories","text":"<p>Scalar Sets can reference DPM subcategories for predefined sets: <pre><code>[subcategory, eba_CU:iso_currencies]  # References predefined currency codes\n</code></pre></p> <p>This provides: - Standardization: Use official code lists - Maintenance: Centrally managed sets - Validation: Automatic validation against official values</p>"},{"location":"information-model/artifacts/scalar-sets/#best-practices","title":"Best Practices","text":""},{"location":"information-model/artifacts/scalar-sets/#readability","title":"Readability","text":"<p>Use meaningful groupings and formatting: <pre><code># Good: Clearly grouped and formatted\n{\n    \"High Risk Asset Classes\": {\"Derivatives\", \"Commodities\", \"Alternatives\"},\n    \"Medium Risk\": {\"Equities\", \"Corporate Bonds\"},\n    \"Low Risk\": {\"Government Bonds\", \"Cash\"}\n}\n\n# Better: Use sets for membership testing\nwhere AssetClass in {\"Derivatives\", \"Commodities\", \"Alternatives\"}\n</code></pre></p>"},{"location":"information-model/artifacts/scalar-sets/#maintainability","title":"Maintainability","text":"<p>For frequently used sets, consider referencing subcategories: <pre><code># Instead of hardcoding:\nwhere Country in {\"ES\", \"PT\", \"IT\", \"FR\"}\n\n# Use subcategory reference:\nwhere Country in [subcategory, eu_southern_countries]\n</code></pre></p>"},{"location":"information-model/artifacts/scalar-sets/#performance","title":"Performance","text":"<p>For large sets used frequently, consider implementation optimizations: - Use hash-based lookups for string sets - Use bit vectors for small integer ranges - Cache compiled sets for repeated use</p>"},{"location":"information-model/artifacts/scalar-sets/#examples-in-context","title":"Examples in Context","text":""},{"location":"information-model/artifacts/scalar-sets/#multi-table-validation","title":"Multi-Table Validation","text":"<pre><code># Ensure consistent currency usage across tables\nwith {c0010}:\n    {F_01.01, r0010}[where CUR in {\"EUR\", \"USD\"}] = \n    {F_02.01, r0010}[where CUR in {\"EUR\", \"USD\"}]\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#conditional-aggregation","title":"Conditional Aggregation","text":"<pre><code># Sum only for specific countries\nsum({F_20.05, r0020-0030, c0010}[where CNT in {\"ES\", \"PT\", \"IT\"}])\n</code></pre>"},{"location":"information-model/artifacts/scalar-sets/#complex-filtering","title":"Complex Filtering","text":"<pre><code># Multiple set-based conditions\n{F_40.01, c0031}[where \n    LIN in {\"123456\", \"789012\"} and\n    TYC in {\"LEI\", \"ISIN\"} and\n    not (STC in {\"Inactive\", \"Suspended\"})\n]\n</code></pre> <p>Performance Tip</p> <p>For sets used in multiple expressions, consider:</p> <ol> <li>Subcategory references for standardized code lists</li> <li>Compilation optimization for frequently used literal sets  </li> <li>Indexing strategies in the underlying data for common membership tests</li> </ol>"},{"location":"information-model/artifacts/scalars/","title":"Scalars","text":"<p>Scalars are the simplest and most fundamental language artifacts in DPM-XL, representing individual values of a specific data type. They serve as the building blocks for more complex data structures and operations.</p>"},{"location":"information-model/artifacts/scalars/#definition","title":"Definition","text":"<p>Scalars are individual values of a certain Data Type.</p> <p>Key characteristics: - Single value: Represents exactly one data point - Typed: Every scalar has a specific, well-defined data type - Atomic: Cannot be decomposed into smaller parts within the language - Immutable: Value and type are fixed once created</p>"},{"location":"information-model/artifacts/scalars/#scalar-types","title":"Scalar Types","text":"<p>Scalars can be of any data type supported by DPM-XL:</p>"},{"location":"information-model/artifacts/scalars/#numeric-scalars","title":"Numeric Scalars","text":"<pre><code>100        # Integer scalar\n3.14159    # Number scalar  \n-42        # Negative integer scalar\n0.5        # Decimal number scalar\n</code></pre>"},{"location":"information-model/artifacts/scalars/#string-scalars","title":"String Scalars","text":"<pre><code>\"Hello\"           # String scalar\n'World'           # String scalar (alternative quotes)\n\"Asset Class A\"   # String with spaces\n\"\"                # Empty string scalar\n</code></pre>"},{"location":"information-model/artifacts/scalars/#boolean-scalars","title":"Boolean Scalars","text":"<pre><code>true     # Boolean true scalar\nfalse    # Boolean false scalar\n</code></pre>"},{"location":"information-model/artifacts/scalars/#temporal-scalars","title":"Temporal Scalars","text":"<pre><code>#2023-12-31#     # Date scalar\n#2023Q4#         # Time period scalar\n#P1Y#            # Duration scalar (1 year)\n</code></pre>"},{"location":"information-model/artifacts/scalars/#dpm-object-scalars","title":"DPM Object Scalars","text":"<pre><code>[item, eba_RT:x11]                    # Category item scalar\n[subcategory, eba_CU:iso_currencies]  # Subcategory scalar\n</code></pre>"},{"location":"information-model/artifacts/scalars/#usage-in-expressions","title":"Usage in Expressions","text":"<p>Scalars appear in expressions in several ways:</p>"},{"location":"information-model/artifacts/scalars/#literals","title":"Literals","text":"<p>Direct scalar values written in expressions: <pre><code>{F_01.01, r0010, c0010} &gt; 1000\n#                         ^^^^ Scalar literal\n</code></pre></p>"},{"location":"information-model/artifacts/scalars/#operation-results","title":"Operation Results","text":"<p>Many operations produce scalar results: <pre><code>sum({F_20.05, r0020-0030, c0010})  # Produces a scalar sum\n</code></pre></p>"},{"location":"information-model/artifacts/scalars/#extracted-from-recordsets","title":"Extracted from Recordsets","text":"<p>Scalars can be extracted from single-record recordsets: <pre><code>{F_01.01, r0010, c0010}  # Single cell selection \u2192 scalar-like behavior\n</code></pre></p>"},{"location":"information-model/artifacts/scalars/#scalar-operations","title":"Scalar Operations","text":""},{"location":"information-model/artifacts/scalars/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>Scalars participate in standard arithmetic: <pre><code>100 + 50           # Addition: produces 150\n3.14 * 2           # Multiplication: produces 6.28\n-5                 # Unary minus: produces -5\nabs(-10)          # Absolute value: produces 10\n</code></pre></p>"},{"location":"information-model/artifacts/scalars/#comparison-operations","title":"Comparison Operations","text":"<p>Scalars can be compared: <pre><code>100 &gt; 50          # Greater than: produces true\n\"abc\" = \"abc\"     # String equality: produces true\n#2023Q1# &lt; #2023Q2#  # Date comparison: produces true\n</code></pre></p>"},{"location":"information-model/artifacts/scalars/#logical-operations","title":"Logical Operations","text":"<p>Boolean scalars support logical operations: <pre><code>true and false    # Conjunction: produces false\nnot true          # Negation: produces false\n</code></pre></p>"},{"location":"information-model/artifacts/scalars/#type-conversion","title":"Type Conversion","text":"<p>Scalars can be cast between compatible types: <pre><code>cast(100, \"string\")    # Integer to string: produces \"100\"\ncast(\"3.14\", number)   # String to number: produces 3.14\n</code></pre></p>"},{"location":"information-model/artifacts/scalars/#special-scalar-values","title":"Special Scalar Values","text":""},{"location":"information-model/artifacts/scalars/#null-values","title":"Null Values","text":"<p>Every data type includes the special value <code>null</code>: - Represents \"no value\" or \"missing value\" - Behaves according to three-valued logic in boolean operations - Propagates through most arithmetic operations</p> <pre><code>100 + null        # Produces null\nnull &gt; 50         # Produces null\nnull and true     # Produces null\n</code></pre>"},{"location":"information-model/artifacts/scalars/#empty-string","title":"Empty String","text":"<p>For string types, <code>null</code> is equivalent to the empty string: <pre><code>null = \"\"         # true for string context\n</code></pre></p>"},{"location":"information-model/artifacts/scalars/#scalar-validation","title":"Scalar Validation","text":"<p>Scalars must satisfy data type constraints:</p>"},{"location":"information-model/artifacts/scalars/#numeric-constraints","title":"Numeric Constraints","text":"<pre><code>sqrt(-1)          # Runtime error: negative square root\n10 / 0            # Runtime error: division by zero\n</code></pre>"},{"location":"information-model/artifacts/scalars/#temporal-constraints","title":"Temporal Constraints","text":"<pre><code>#2023-02-30#      # Invalid date\n#2023Q5#          # Invalid quarter\n</code></pre>"},{"location":"information-model/artifacts/scalars/#reference-constraints","title":"Reference Constraints","text":"<pre><code>[item, invalid_code]  # Error: item does not exist\n</code></pre>"},{"location":"information-model/artifacts/scalars/#performance-characteristics","title":"Performance Characteristics","text":"<p>Scalars offer optimal performance characteristics:</p>"},{"location":"information-model/artifacts/scalars/#memory-efficiency","title":"Memory Efficiency","text":"<ul> <li>Minimal memory footprint</li> <li>Direct value storage without overhead</li> <li>Efficient copying and passing</li> </ul>"},{"location":"information-model/artifacts/scalars/#computational-speed","title":"Computational Speed","text":"<ul> <li>Direct CPU operations</li> <li>No indirection or lookup costs</li> <li>Optimal for mathematical calculations</li> </ul>"},{"location":"information-model/artifacts/scalars/#cache-friendliness","title":"Cache Friendliness","text":"<ul> <li>Small size enables efficient caching</li> <li>Good CPU cache utilization</li> <li>Fast access patterns</li> </ul>"},{"location":"information-model/artifacts/scalars/#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"information-model/artifacts/scalars/#value-storage","title":"Value Storage","text":"<p>Implement scalars as direct value storage: <pre><code>class Scalar {\n    DataType type;\n    Value value;        // Union of all possible value types\n    boolean isNull;\n}\n</code></pre></p>"},{"location":"information-model/artifacts/scalars/#type-safety","title":"Type Safety","text":"<p>Enforce type constraints at runtime: - Validate operations match type requirements - Perform explicit casting where allowed - Fail fast on type errors</p>"},{"location":"information-model/artifacts/scalars/#null-handling","title":"Null Handling","text":"<p>Implement consistent null propagation: - Most operations return null if any operand is null - Comparison operations handle null according to three-valued logic - Aggregation operations typically ignore nulls</p>"},{"location":"information-model/artifacts/scalars/#examples-in-context","title":"Examples in Context","text":""},{"location":"information-model/artifacts/scalars/#simple-validation","title":"Simple Validation","text":"<pre><code>{F_01.01, r0010, c0010} = 100\n#                         ^^^ Scalar literal for comparison\n</code></pre>"},{"location":"information-model/artifacts/scalars/#calculation-with-constants","title":"Calculation with Constants","text":"<pre><code>{F_01.01, r0010, c0010} * 0.8 + 1000\n#                         ^^^   ^^^^ Scalar constants\n</code></pre>"},{"location":"information-model/artifacts/scalars/#conditional-logic","title":"Conditional Logic","text":"<pre><code>if {F_01.01, r0010, c0010} &gt; 0 then 1 else 0\n#                             ^        ^    ^ Scalar values\n</code></pre> <p>Scalar Behavior with Recordsets</p> <p>When scalars are used with recordsets in binary operations, the scalar is conceptually \"broadcast\" to match each record in the recordset. This enables operations like:</p> <pre><code>{F_01.01, r0010-0020, c0010} * 1.1  # Multiply each record by 1.1\n</code></pre>"},{"location":"introduction/","title":"Introduction","text":"<p>This section provides the foundational context for understanding the DPM Expression Language (DPM-XL), its purpose, design principles, and how it fits into the broader regulatory reporting ecosystem.</p>"},{"location":"introduction/#what-youll-learn","title":"What You'll Learn","text":"<p>The introduction covers four key areas:</p>"},{"location":"introduction/#why-dpm-xl","title":"Why DPM-XL","text":"<p>Understanding the business and technical drivers that led to the creation of DPM-XL, including: - The need for formal expression languages in regulatory reporting - Challenges with semi-formal approaches - Benefits of full formalization</p>"},{"location":"introduction/#dpm-xl-vs-dpm-ml","title":"DPM-XL vs DPM-ML","text":"<p>Exploring the dual representation approach: - DPM-XL: The human-readable expression language - DPM-ML: The structured metamodel representation - When and why to use each representation</p>"},{"location":"introduction/#formalization-approach","title":"Formalization Approach","text":"<p>The three-pillar methodology used to formalize the language: - Information Model: Data structures and artifacts - Grammar: Syntactic rules and parsing - Semantic Specification: Operator behavior and constraints</p>"},{"location":"introduction/#technical-audience","title":"Technical Audience","text":"<p>This documentation is primarily designed for:</p> <ul> <li>Technical architects implementing DPM-XL engines</li> <li>Software developers building validation systems</li> <li>Business analysts with technical background writing complex validations</li> <li>Standards specialists working on regulatory frameworks</li> </ul> <p>While business users can benefit from understanding the concepts, the detailed specifications are aimed at those who need to implement or deeply understand the language mechanics.</p>"},{"location":"introduction/#document-scope","title":"Document Scope","text":"<p>This documentation focuses on the formal specification of DPM-XL, covering:</p> <ul> <li>Complete information model</li> <li>All operators and their semantics</li> <li>Data type system and casting rules</li> <li>Error handling and null treatment</li> <li>DPM-ML metamodel representation</li> </ul> <p>It complements (but does not replace) grammar specifications and implementation guides that may be provided separately.</p> <p>Complementary Documents</p> <p>This documentation works alongside: - EBNF grammar specification (for parser implementation) - Semantic specification documents (for detailed operator semantics) - Implementation guides (for specific deployment scenarios)</p>"},{"location":"introduction/approach/","title":"Formalization Approach","text":"<p>The formalization of DPM-XL follows a systematic, three-pillar methodology that ensures complete specification while maintaining practical usability. This approach was inspired by the Validation and Transformation Language specification and adapted for the regulatory reporting domain.</p>"},{"location":"introduction/approach/#the-three-pillars","title":"The Three Pillars","text":"<p>The formalization rests on three complementary pillars, each addressing different aspects of language specification:</p> graph TB     subgraph \"Language Formalization\"         IM[Information Model]         GR[Grammar]         SS[Semantic Specification]     end      IM --&gt; |Defines| DATA[Data Structures &amp; Types]     GR --&gt; |Defines| SYNT[Syntax &amp; Parsing Rules]     SS --&gt; |Defines| SEM[Operator Behavior]      DATA --&gt; ENG[Language Engine]     SYNT --&gt; ENG     SEM --&gt; ENG      style IM fill:#e3f2fd     style GR fill:#f3e5f5     style SS fill:#e8f5e8"},{"location":"introduction/approach/#pillar-1-information-model","title":"Pillar 1: Information Model","text":""},{"location":"introduction/approach/#purpose","title":"Purpose","text":"<p>Defines the fundamental data structures and artifacts that the language operates on.</p>"},{"location":"introduction/approach/#scope","title":"Scope","text":"<ul> <li>Operation structure: How expressions are composed</li> <li>Language artifacts: Scalars, scalar sets, and recordsets</li> <li>Data types: Number, string, boolean, time, etc.</li> <li>Component types: Keys, facts, and attributes</li> <li>Casting rules: Type conversion specifications</li> </ul>"},{"location":"introduction/approach/#key-contributions","title":"Key Contributions","text":"<ul> <li>Establishes the conceptual foundation</li> <li>Defines data structures independent of syntax</li> <li>Specifies type system and compatibility rules</li> <li>Provides the vocabulary for semantic specifications</li> </ul>"},{"location":"introduction/approach/#example","title":"Example","text":"<pre><code>Recordset Structure:\n\u251c\u2500\u2500 Key Components (unique identification)\n\u251c\u2500\u2500 Fact Component (the measured value)\n\u2514\u2500\u2500 Attribute Components (metadata)\n</code></pre>"},{"location":"introduction/approach/#pillar-2-grammar","title":"Pillar 2: Grammar","text":""},{"location":"introduction/approach/#purpose_1","title":"Purpose","text":"<p>Provides the technical definition of language syntax using formal notation.</p>"},{"location":"introduction/approach/#scope_1","title":"Scope","text":"<ul> <li>Syntactic rules: How expressions are structured</li> <li>Token definitions: Keywords, operators, literals</li> <li>Precedence rules: Order of operations</li> <li>Parsing specifications: How to build syntax trees</li> </ul>"},{"location":"introduction/approach/#format","title":"Format","text":"<p>Extended Backus-Naur Form (EBNF) notation in separate specification files.</p>"},{"location":"introduction/approach/#key-contributions_1","title":"Key Contributions","text":"<ul> <li>Enables automatic parser generation</li> <li>Eliminates syntactic ambiguity</li> <li>Provides formal basis for tooling</li> <li>Ensures consistent interpretation across implementations</li> </ul>"},{"location":"introduction/approach/#example-conceptual","title":"Example (Conceptual)","text":"<pre><code>expression ::= term (('+' | '-') term)*\nterm ::= factor (('*' | '/') factor)*\nfactor ::= number | '(' expression ')'\n</code></pre>"},{"location":"introduction/approach/#pillar-3-semantic-specification","title":"Pillar 3: Semantic Specification","text":""},{"location":"introduction/approach/#purpose_2","title":"Purpose","text":"<p>Formally defines the behavior and constraints of every operator in the language.</p>"},{"location":"introduction/approach/#scope_2","title":"Scope","text":"<ul> <li>Operator semantics: What each operator does</li> <li>Input constraints: Valid parameter types and structures</li> <li>Output specifications: Result types and structures</li> <li>Error conditions: When operations fail</li> <li>Edge case handling: Null values, empty sets, etc.</li> </ul>"},{"location":"introduction/approach/#key-contributions_2","title":"Key Contributions","text":"<ul> <li>Ensures deterministic behavior</li> <li>Provides complete specification for implementation</li> <li>Covers all edge cases and error conditions</li> <li>Enables automated testing and verification</li> </ul>"},{"location":"introduction/approach/#example_1","title":"Example","text":"<p>For the addition operator (<code>+</code>): - Input: Two numeric operands (scalars or recordsets) - Output: Numeric result with appropriate type promotion - Null handling: Returns null if either operand is null - Recordset behavior: Element-wise addition with key matching</p>"},{"location":"introduction/approach/#integration-and-consistency","title":"Integration and Consistency","text":"<p>The three pillars work together to provide a complete, consistent specification:</p>"},{"location":"introduction/approach/#cross-pillar-validation","title":"Cross-Pillar Validation","text":"<ul> <li>Grammar validates Information Model: Syntax supports all defined structures</li> <li>Semantics reference Information Model: Operators work on defined data types</li> <li>Semantics constrain Grammar: Legal syntax produces meaningful operations</li> </ul>"},{"location":"introduction/approach/#consistency-checks","title":"Consistency Checks","text":"<ul> <li>All data types in the information model have corresponding grammar rules</li> <li>Every syntactic construct has defined semantics</li> <li>Semantic specifications match information model capabilities</li> </ul>"},{"location":"introduction/approach/#reverse-engineering-approach","title":"Reverse Engineering Approach","text":"<p>The formalization followed a pragmatic approach that prioritized backward compatibility and real-world usage:</p>"},{"location":"introduction/approach/#starting-point","title":"Starting Point","text":"<p>Rather than designing a new language from scratch, the formalization began with existing validation rules published by EBA and EIOPA.</p>"},{"location":"introduction/approach/#methodology","title":"Methodology","text":"<ol> <li>Analysis: Examine existing semi-formal expressions</li> <li>Pattern Recognition: Identify common structures and operators</li> <li>Abstraction: Extract underlying concepts and rules</li> <li>Formalization: Create precise specifications that support existing usage</li> <li>Extension: Add necessary features while maintaining compatibility</li> </ol>"},{"location":"introduction/approach/#key-principle","title":"Key Principle","text":"<p>The language that is currently used should change as little as possible.</p> <p>This constraint ensured that: - Existing rules remain valid - Learning curve is minimized for current users - Migration to formal specification is smooth - Investment in existing rules is preserved</p>"},{"location":"introduction/approach/#quality-assurance","title":"Quality Assurance","text":"<p>The three-pillar approach includes built-in quality assurance mechanisms:</p>"},{"location":"introduction/approach/#completeness-verification","title":"Completeness Verification","text":"<ul> <li>Information Model: All necessary data structures are defined</li> <li>Grammar: All language constructs have syntax rules</li> <li>Semantics: Every operator has complete behavioral specification</li> </ul>"},{"location":"introduction/approach/#consistency-validation","title":"Consistency Validation","text":"<ul> <li>Cross-references between pillars are validated</li> <li>No contradictions between syntax and semantics</li> <li>Type system is coherent and complete</li> </ul>"},{"location":"introduction/approach/#implementation-validation","title":"Implementation Validation","text":"<ul> <li>Formal specifications enable automated testing</li> <li>Reference implementations verify specification correctness</li> <li>Edge cases are explicitly handled</li> </ul>"},{"location":"introduction/approach/#benefits-for-implementers","title":"Benefits for Implementers","text":"<p>This structured approach provides clear benefits for those implementing DPM-XL engines:</p>"},{"location":"introduction/approach/#clear-boundaries","title":"Clear Boundaries","text":"<p>Each pillar has distinct responsibilities, making implementation more manageable.</p>"},{"location":"introduction/approach/#incremental-implementation","title":"Incremental Implementation","text":"<p>Teams can implement pillars independently: - Parser team focuses on grammar - Type system team focuses on information model - Operator team focuses on semantics</p>"},{"location":"introduction/approach/#automated-validation","title":"Automated Validation","text":"<p>Formal specifications enable: - Automated test generation - Specification compliance checking - Cross-implementation validation</p>"},{"location":"introduction/approach/#future-evolution","title":"Future Evolution","text":"<p>The three-pillar structure supports language evolution: - New operators can be added with clear semantic specifications - Grammar can be extended systematically - Information model can evolve while maintaining backward compatibility</p>"},{"location":"introduction/approach/#documentation-organization","title":"Documentation Organization","text":"<p>This documentation follows the three-pillar structure:</p> Pillar Documentation Sections Information Model Information Model, Language Specification Grammar Reference/Grammar Semantic Specification Operators sections <p>Each section builds upon the others, creating a comprehensive and internally consistent specification.</p> <p>Implementation Strategy</p> <p>When implementing a DPM-XL engine:</p> <ol> <li>Start with Information Model - Understand data structures first</li> <li>Implement Grammar - Build parser for syntax validation</li> <li>Add Semantics - Implement operators one category at a time</li> <li>Test Thoroughly - Use formal specs to generate comprehensive test suites</li> </ol>"},{"location":"introduction/dpm-xl-vs-dpm-ml/","title":"DPM-XL and DPM-ML","text":"<p>The DPM Operations specification includes two complementary representations of the same logical operations: DPM-XL (expression language) and DPM-ML (metamodel language). Understanding when and why to use each representation is crucial for effective implementation.</p>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#two-representations-same-semantics","title":"Two Representations, Same Semantics","text":"<p>Both DPM-XL and DPM-ML represent identical calculations and validations, but serve different purposes in the development and execution lifecycle:</p> graph TB     BR[Business Rule] --&gt; XL[DPM-XL Expression]     XL --&gt; ML[DPM-ML Structure]     ML --&gt; EX[Execution Engine]      XL -.-&gt; |Direct Compilation| EX      style XL fill:#e3f2fd     style ML fill:#f3e5f5     style EX fill:#e8f5e8"},{"location":"introduction/dpm-xl-vs-dpm-ml/#dpm-xl-the-expression-language","title":"DPM-XL: The Expression Language","text":""},{"location":"introduction/dpm-xl-vs-dpm-ml/#purpose","title":"Purpose","text":"<p>DPM-XL serves as the primary interface for business users and rule authors.</p>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#characteristics","title":"Characteristics","text":""},{"location":"introduction/dpm-xl-vs-dpm-ml/#human-readable","title":"Human-Readable","text":"<pre><code>with {F_01.01, c0010, default:0}:\n    {r0010} = {r0020} + {r0030} + {r0040}\n</code></pre>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#business-friendly-syntax","title":"Business-Friendly Syntax","text":"<ul> <li>Uses familiar table, row, column references</li> <li>Intuitive operator names (<code>sum</code>, <code>count</code>, <code>max</code>)</li> <li>Natural expression structure</li> </ul>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#rendering-based-references","title":"Rendering-Based References","text":"<ul> <li>References data by table/row/column positions</li> <li>Matches how business users see and understand reports</li> <li>Aligns with existing documentation and specifications</li> </ul>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#use-cases","title":"Use Cases","text":"<ul> <li>Rule authoring by business analysts</li> <li>Documentation and communication</li> <li>Validation rule specifications</li> <li>Training and education materials</li> </ul>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#example","title":"Example","text":"<pre><code>{F_40.01, c0031}[where LIN = \"123456\"] \n&gt;= 0.8 * {F_40.02, c0060}[where LIN = \"123456\"]\n</code></pre>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#dpm-ml-the-metamodel-language","title":"DPM-ML: The Metamodel Language","text":""},{"location":"introduction/dpm-xl-vs-dpm-ml/#purpose_1","title":"Purpose","text":"<p>DPM-ML provides a structured representation optimized for storage, processing, and execution.</p>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#characteristics_1","title":"Characteristics","text":""},{"location":"introduction/dpm-xl-vs-dpm-ml/#structured-data","title":"Structured Data","text":"<ul> <li>Database-friendly format</li> <li>No parsing required</li> <li>Direct processing by engines</li> </ul>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#variable-based-references","title":"Variable-Based References","text":"<ul> <li>References actual business variables</li> <li>Stable over time (variables represent concepts)</li> <li>Independent of rendering changes</li> </ul>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#execution-optimized","title":"Execution-Optimized","text":"<ul> <li>Tree structure for operator precedence</li> <li>Efficient processing algorithms</li> <li>Cacheable intermediate results</li> </ul>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#use-cases_1","title":"Use Cases","text":"<ul> <li>Database storage of operations</li> <li>Execution engines and compilers</li> <li>Cross-language translation</li> <li>Performance optimization</li> </ul>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#benefits","title":"Benefits","text":""},{"location":"introduction/dpm-xl-vs-dpm-ml/#stability","title":"Stability","text":"<p>Variables represent business concepts that remain stable even when report layouts change.</p>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#performance","title":"Performance","text":"<p>No expression parsing during execution - structure is pre-computed.</p>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#flexibility","title":"Flexibility","text":"<p>Can be generated from languages other than DPM-XL if needed.</p>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#key-differences","title":"Key Differences","text":"Aspect DPM-XL DPM-ML Primary Users Business analysts, rule authors Developers, execution engines Format Text expressions Structured data (database tables) References Table/row/column (rendering) Variables (business concepts) Parsing Required at runtime Pre-parsed structure Readability High (business-friendly) Low (technical structure) Stability Affected by layout changes Stable over time Processing Parse \u2192 Execute Direct execution"},{"location":"introduction/dpm-xl-vs-dpm-ml/#standard-key-components","title":"Standard Key Components","text":"<p>The two representations handle dimensional references differently:</p>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#dpm-xl-standard-keys","title":"DPM-XL Standard Keys","text":"<ul> <li>Row Key (<code>r</code>): Identifies specific rows in tables</li> <li>Column Key (<code>c</code>): Identifies specific columns in tables  </li> <li>Sheet Key (<code>s</code>): Identifies specific sheets in tables</li> </ul>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#dpm-ml-standard-keys","title":"DPM-ML Standard Keys","text":"<ul> <li>X Index: Abstract index for matching variables</li> <li>Y Index: Abstract index for matching variables</li> <li>Z Index: Abstract index for matching variables</li> </ul> <p>The indexes ensure proper variable matching during operations without depending on specific rendering positions.</p>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#conversion-process","title":"Conversion Process","text":"<p>DPM-ML is automatically derived from DPM-XL:</p> graph LR     A[DPM-XL Expression] --&gt; B[Parser]     B --&gt; C[Syntax Tree]     C --&gt; D[Variable Resolution]     D --&gt; E[DPM-ML Structure]      style A fill:#e3f2fd     style E fill:#f3e5f5"},{"location":"introduction/dpm-xl-vs-dpm-ml/#steps","title":"Steps","text":"<ol> <li>Parse DPM-XL expression into syntax tree</li> <li>Resolve table/row/column references to variables</li> <li>Transform rendering keys to abstract indexes</li> <li>Generate DPM-ML database structure</li> </ol>"},{"location":"introduction/dpm-xl-vs-dpm-ml/#shared-elements","title":"Shared Elements","text":"<p>Both representations share:</p> <ul> <li>Identical operators and semantics</li> <li>Same information model (scalars, sets, recordsets)</li> <li>Common data types and casting rules</li> <li>Identical null handling and error conditions</li> </ul> <p>Implementation Guidance</p> <p>For Rule Authors: Use DPM-XL for creating and documenting business rules</p> <p>For Engine Developers: Process DPM-XL input but execute using DPM-ML structures for optimal performance</p> <p>For Integration: Store operations in DPM-ML format for stability and efficiency</p>"},{"location":"introduction/why/","title":"Why DPM-XL?","text":"<p>The development of the DPM Expression Language addresses critical challenges in regulatory reporting and data validation that have persisted across financial institutions and regulatory bodies.</p>"},{"location":"introduction/why/#the-problem-semi-formal-expressions","title":"The Problem: Semi-Formal Expressions","text":"<p>For years, regulatory authorities like EBA and EIOPA have used semi-formal expression languages to communicate data validation requirements. While this approach offered some benefits, it created significant limitations:</p>"},{"location":"introduction/why/#limited-automation","title":"Limited Automation","text":"<ul> <li>Manual interpretation required: Semi-formal expressions needed human interpretation before implementation</li> <li>Inconsistent translations: Different developers might interpret the same rule differently</li> <li>No direct execution: Expressions couldn't be compiled or run directly</li> </ul>"},{"location":"introduction/why/#translation-challenges","title":"Translation Challenges","text":"<ul> <li>Error-prone process: Converting business rules to executable code introduced errors</li> <li>Time-consuming: Each rule required manual coding and testing</li> <li>Version control issues: Changes to business rules required re-coding and re-testing</li> </ul>"},{"location":"introduction/why/#compliance-risks","title":"Compliance Risks","text":"<ul> <li>Implementation gaps: Misunderstanding of requirements led to incorrect implementations</li> <li>Audit challenges: Difficult to verify that implemented rules matched intended specifications</li> <li>Regulatory uncertainty: Institutions couldn't be certain their interpretation was correct</li> </ul>"},{"location":"introduction/why/#the-solution-full-formalization","title":"The Solution: Full Formalization","text":"<p>DPM-XL addresses these challenges by providing a fully formal expression language that bridges the gap between business requirements and technical implementation.</p>"},{"location":"introduction/why/#complete-automation","title":"Complete Automation","text":"graph LR     A[Business Rule] --&gt; B[DPM-XL Expression]     B --&gt; C[Automated Compilation]     C --&gt; D[Direct Execution]      style B fill:#e1f5fe     style C fill:#f3e5f5     style D fill:#e8f5e8"},{"location":"introduction/why/#key-benefits","title":"Key Benefits","text":""},{"location":"introduction/why/#unambiguous-specification","title":"Unambiguous Specification","text":"<ul> <li>Every operator has precise semantics</li> <li>Clear data type system with defined casting rules</li> <li>Explicit null handling and error conditions</li> <li>Formal grammar prevents ambiguous interpretations</li> </ul>"},{"location":"introduction/why/#direct-execution","title":"Direct Execution","text":"<ul> <li>Expressions can be compiled directly to executable code</li> <li>No manual translation step required</li> <li>Consistent results across different implementations</li> <li>Real-time validation during rule authoring</li> </ul>"},{"location":"introduction/why/#improved-quality","title":"Improved Quality","text":"<ul> <li>Syntax validation during rule creation</li> <li>Type checking prevents common errors</li> <li>Comprehensive testing of edge cases</li> <li>Automated verification of rule consistency</li> </ul>"},{"location":"introduction/why/#reduced-costs","title":"Reduced Costs","text":"<ul> <li>Faster implementation of new validation rules</li> <li>Lower maintenance overhead</li> <li>Reduced testing requirements</li> <li>Fewer implementation errors</li> </ul>"},{"location":"introduction/why/#real-world-impact","title":"Real-World Impact","text":""},{"location":"introduction/why/#for-regulatory-bodies","title":"For Regulatory Bodies","text":"<ul> <li>Faster rule deployment: New validations can be published and implemented quickly</li> <li>Consistent interpretation: All institutions implement rules identically</li> <li>Better compliance monitoring: Automated validation of submitted data</li> <li>Reduced regulatory burden: Less time spent clarifying rule interpretation</li> </ul>"},{"location":"introduction/why/#for-financial-institutions","title":"For Financial Institutions","text":"<ul> <li>Reduced implementation time: Rules can be deployed automatically</li> <li>Lower compliance costs: Less manual work in validation system maintenance</li> <li>Improved accuracy: Elimination of human interpretation errors</li> <li>Better auditability: Clear traceability from business rule to implementation</li> </ul>"},{"location":"introduction/why/#for-software-vendors","title":"For Software Vendors","text":"<ul> <li>Standardized implementations: Single engine can handle all DPM-XL expressions</li> <li>Reduced development time: No need to interpret each rule individually</li> <li>Better customer support: Consistent behavior across all deployments</li> <li>Innovation enablement: Focus on value-added features rather than basic interpretation</li> </ul>"},{"location":"introduction/why/#historical-context","title":"Historical Context","text":"<p>The formalization of DPM-XL represents a natural evolution in regulatory technology:</p> <ol> <li>Manual Rules Era: Paper-based rules with narrative descriptions</li> <li>Semi-Formal Era: Structured expressions requiring interpretation</li> <li>Formal Era: Fully specified languages enabling automation</li> </ol> <p>This evolution mirrors similar developments in other domains where precision and automation became critical for scale and reliability.</p> <p>Key Takeaway</p> <p>DPM-XL transforms regulatory validation from a manual, error-prone process into an automated, reliable system that benefits all stakeholders in the regulatory reporting ecosystem.</p>"}]}